{
  "generated_at": "2026-02-10T09:56:51.229Z",
  "layers": [
    {
      "id": "observability-dashboard",
      "name": "Observability Dashboard",
      "type": "layer",
      "layer": null,
      "color": "sky",
      "icon": "ðŸ“Š",
      "description": "Runtime Visibility â€” read-only web UI that observes but never mutates. The single pane of glass for both observation and control.",
      "tags": "[\"read-only\",\"web ui\",\"live updates\"]",
      "sort_order": 10,
      "children": [
        {
          "id": "live-dashboard",
          "name": "Live Dashboard",
          "type": "component",
          "layer": "observability-dashboard",
          "color": "sky",
          "icon": "ðŸ“Š",
          "description": "Real-time view of the entire runtime. Read-only â€” it observes but never mutates. Built as a simple web app (React / plain HTML) that polls the State Store + Supervisor health API. Runs as a separate process managed by the Supervisor. Think: the runtime equivalent of the process tree diagram, but live. Reads from two sources: State Store (goals, tasks, tool logs, escalations, checkpoints) and Supervisor health API (process status, heartbeat data, resource usage). It writes nothing â€” pure read-only observer. Optional: SSE/WebSocket push from State Store for live updates without polling. Human Gate approval actions can be embedded here, making it the single pane of glass for both observation and control.",
          "tags": "[\"read-only\",\"web ui\",\"sse/websocket\"]",
          "sort_order": 11,
          "versions": {
            "mvp": {
              "content": "Single-page web app showing process status (up/down) and current goal. Polls Supervisor health API every 5s. Basic goal queue display from State Store. Static HTML + vanilla JS.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "overview": {
              "content": "Real-time view of the entire runtime. Read-only â€” it observes but never mutates. Built as a simple web app (React / plain HTML) that polls the State Store + Supervisor health API. Runs as a separate process managed by the Supervisor. Think: the runtime equivalent of the process tree diagram, but live. Data sources: State Store â†’ goals, tasks, tool call logs, escalations, checkpoints, fast-path records, injection events. Supervisor Health API â†’ process status, uptime, restart count, memory, current model per instance. No direct process inspection â€” dashboard never connects to OpenCode or proxies directly. Push vs Poll: SSE from State Store for live updates; poll Supervisor health every 5s. Human Gate embedded: approval buttons for gated tasks + escalation responses in same UI.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "v1": {
              "content": "Full process tree view with live status. Goal & task feed with click-to-inspect. Tool call timeline with filtering. Security events panel. Escalation queue with response actions.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "v2": {
              "content": "SSE/WebSocket for real-time push updates. Entity Explorer for User KG. Repo Map for Code Graph. Embedded Human Gate approval UI. Performance metrics and resource graphs.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {
            "mvp": [
              {
                "filename": "mvp-dashboard.feature",
                "title": "Live Dashboard (MVP)",
                "content": "Feature: Live Dashboard (MVP)\n  A read-only web UI showing process status and current goal.\n  Polls the Supervisor health API and State Store.\n\n  Background:\n    Given the Dashboard web app is running\n\n  Scenario: Display process status\n    Given the Supervisor health API reports Meta-Agent as \"running\" and Worker as \"running\"\n    When the Dashboard polls the health API\n    Then both processes are shown with \"running\" status indicators\n\n  Scenario: Display current goal\n    Given the State Store contains a goal \"Build user auth\" with status \"in-progress\"\n    When the Dashboard polls the State Store\n    Then the current goal \"Build user auth\" is displayed\n    And its status shows \"in-progress\"\n\n  Scenario: Auto-refresh on interval\n    Given the Dashboard is displaying process status\n    When 5 seconds have elapsed\n    Then the Dashboard polls the health API again\n    And the display updates with fresh data\n\n  Scenario: Show offline state\n    Given the Supervisor health API is unreachable\n    When the Dashboard polls the health API\n    Then a \"Supervisor Unreachable\" indicator is shown\n\n  Scenario: Read-only â€” no mutation endpoints\n    Given the Dashboard is running\n    Then it exposes no POST, PUT, or DELETE endpoints\n    And all data access is via GET requests\n"
              }
            ]
          }
        },
        {
          "id": "live-process-view",
          "name": "Live Process View",
          "type": "component",
          "layer": "observability-dashboard",
          "color": "sky",
          "icon": "ðŸ”´",
          "description": "Process tree with real-time status: running, recovering, crashed, paused for every child. Uptime, restart count, current model, memory usage per instance.",
          "tags": "[\"running\",\"recovering\",\"crashed\",\"paused\"]",
          "sort_order": 12,
          "versions": {
            "overview": {
              "content": "Process tree with real-time status: running, recovering, crashed, paused for every child. Uptime, restart count, current model, memory usage per instance.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "goal-task-feed",
          "name": "Goal & Task Feed",
          "type": "component",
          "layer": "observability-dashboard",
          "color": "sky",
          "icon": "ðŸ“‹",
          "description": "Live stream of the Goal Queue. Current goal, decomposed sub-tasks, completion status. See what the Meta-Agent is planning and what the Worker is executing. Clickable to inspect full task payloads.",
          "tags": "[\"live stream\",\"clickable\",\"task payloads\"]",
          "sort_order": 13,
          "versions": {
            "overview": {
              "content": "Live stream of the Goal Queue. Current goal, decomposed sub-tasks, completion status. See what the Meta-Agent is planning and what the Worker is executing. Clickable to inspect full task payloads.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "tool-call-timeline",
          "name": "Tool Call Timeline",
          "type": "component",
          "layer": "observability-dashboard",
          "color": "sky",
          "icon": "ðŸ”§",
          "description": "Chronological feed of every tool call (both instances). Shows: tool name, args (truncated), response status, latency, sanitiser verdict (pass/block). Filterable by instance, tool, and status. This is your debugging lifeline.",
          "tags": "[\"chronological\",\"filterable\",\"debugging lifeline\"]",
          "sort_order": 14,
          "versions": {
            "overview": {
              "content": "Chronological feed of every tool call (both instances). Shows: tool name, args (truncated), response status, latency, sanitiser verdict (pass/block). Filterable by instance, tool, and status. This is your debugging lifeline.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "security-events",
          "name": "Security Events",
          "type": "component",
          "layer": "observability-dashboard",
          "color": "sky",
          "icon": "ðŸ›¡",
          "description": "Sanitiser verdicts, blocked injections with raw payload preview, injection frequency per tool, auto-disable events. Links to full audit log entries. Alerts when injection rate exceeds threshold.",
          "tags": "[\"audit log\",\"injection frequency\",\"auto-disable\"]",
          "sort_order": 15,
          "versions": {
            "overview": {
              "content": "Sanitiser verdicts, blocked injections with raw payload preview, injection frequency per tool, auto-disable events. Links to full audit log entries. Alerts when injection rate exceeds threshold.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "escalation-queue",
          "name": "Escalation Queue",
          "type": "component",
          "layer": "observability-dashboard",
          "color": "sky",
          "icon": "â¸",
          "description": "Worker escalation requests waiting for Meta-Agent or human review. Shows the Worker's question, context snapshot, and available actions: respond, override, or abort task.",
          "tags": "[\"respond\",\"override\",\"abort\"]",
          "sort_order": 16,
          "versions": {
            "overview": {
              "content": "Worker escalation requests waiting for Meta-Agent or human review. Shows the Worker's question, context snapshot, and available actions: respond, override, or abort task.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "entity-explorer",
          "name": "Entity Explorer",
          "type": "component",
          "layer": "observability-dashboard",
          "color": "sky",
          "icon": "ðŸ‘¤",
          "description": "Browse the User Knowledge Graph. See people, projects, preferences, and their relationships. Understand what the agents \"know about you\".",
          "tags": "[\"new\",\"user kg\",\"browse\"]",
          "sort_order": 17,
          "versions": {
            "overview": {
              "content": "Browse the User Knowledge Graph. See people, projects, preferences, and their relationships. Understand what the agents \"know about you\".",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "repo-map",
          "name": "Repo Map",
          "type": "component",
          "layer": "observability-dashboard",
          "color": "sky",
          "icon": "ðŸ—º",
          "description": "Visualise the Code Graph. Module hierarchy, file deps, data flows. See the agent's structural understanding of your codebase.",
          "tags": "[\"new\",\"code graph\",\"visualise\"]",
          "sort_order": 18,
          "versions": {
            "overview": {
              "content": "Visualise the Code Graph. Module hierarchy, file deps, data flows. See the agent's structural understanding of your codebase.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "human-gate-dashboard",
          "name": "Human Gate (Dashboard)",
          "type": "component",
          "layer": "observability-dashboard",
          "color": "sky",
          "icon": "â›³",
          "description": "Approval queue + escalation responses. Gate actions embeddable in dashboard UI.",
          "tags": "[\"approval\",\"embedded\"]",
          "sort_order": 19,
          "versions": {
            "overview": {
              "content": "Approval queue + escalation responses. Gate actions embeddable in dashboard UI.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        }
      ],
      "versions": {
        "overview": {
          "content": "Read-only web UI. Process view, goal feed, tool timeline, security events, graph explorers. The dashboard is a thin web UI (React / plain HTML) that reads from two sources: the State Store (goals, tasks, tool logs, escalations, checkpoints) and the Supervisor's health API (process status, heartbeat data, resource usage). It writes nothing â€” pure read-only observer. Optional: SSE/WebSocket push from State Store for live updates without polling. The Human Gate approval actions can be embedded here too, making it the single pane of glass for both observation and control.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      }
    },
    {
      "id": "supervisor-layer",
      "name": "Supervisor",
      "type": "layer",
      "layer": null,
      "color": "purple",
      "icon": "ðŸ‘",
      "description": "The Only Immortal Process â€” process management, signal handling, recovery state machine. No LLM, no planning. If it dies, systemd/Docker restarts it.",
      "tags": "[\"immortal\",\"no llm\",\"process manager\"]",
      "sort_order": 20,
      "children": [
        {
          "id": "supervisor",
          "name": "Supervisor",
          "type": "component",
          "layer": "supervisor-layer",
          "color": "purple",
          "icon": "ðŸ‘",
          "description": "Manages all child processes. Heartbeat + crash recovery with tiered priority. No LLM, no planning â€” just process management, signal handling, and the recovery state machine. This is what makes it stable: it has almost no reasons to crash. If it does, systemd/Docker restarts it. Exposes a health API (HTTP on :9100) for the dashboard. Kill switch: /stop HTTP endpoint + SIGTERM handler â†’ instant halt of all children. Emergency brake for runaway agents.",
          "tags": "[\"immortal\",\"health api\",\"kill switch\",\"no llm\"]",
          "sort_order": 21,
          "versions": {
            "mvp": {
              "content": "Spawn and monitor two child processes (meta-agent, worker). Detect crashes via waitpid(). Restart crashed children with basic retry logic. Expose /health HTTP endpoint returning JSON process status. Handle SIGTERM for graceful shutdown of all children.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "overview": {
              "content": "Manages all child processes. Heartbeat + crash recovery with tiered priority. No LLM, no planning â€” just process management, signal handling, and the recovery state machine. This is what makes it stable: it has almost no reasons to crash. If it does, systemd/Docker restarts it. Exposes a health API (HTTP on :9100) for the dashboard. Kill switch: /stop HTTP endpoint + SIGTERM handler â†’ instant halt of all children. Why a Supervisor, not a cron job? (1) Instant detection: waitpid() returns the moment a child exits. Cron's worst-case latency = poll interval. (2) Crash loop handling: Supervisor tracks restart count + applies exponential backoff. (3) Multi-step recovery: kill â†’ checkpoint read â†’ config rebuild â†’ context inject â†’ respawn. (4) Lifecycle ownership: Supervisor owns the full process tree â€” PIDs, health, state. (5) Signal handling: catches SIGTERM/SIGCHLD and coordinates graceful shutdown. Stability hierarchy: Tier âˆž (Supervisor) immortal â†’ Tier 0 (Meta-Agent) recovered first â†’ Tier 1 (Worker) expendable. Recovery order: Supervisor â†’ Meta-Agent â†’ Worker. Each tier can recover the one below it.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "v1": {
              "content": "Add exponential backoff on repeated crashes. Liveness probe (hang detection via output timeout_ms). Recovery state machine with tiered priority (meta-agent first). Checkpoint-aware recovery â€” read last checkpoint before respawn. Human Gate alerting after max 5 retries.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "v2": {
              "content": "Full config-as-code DSL for spawn configuration. Resource monitoring (memory, CPU per child). Kill switch /stop HTTP endpoint. Dashboard SSE push for process events. Per-instance gate policies. Runtime flag switching for gate modes.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {
            "mvp": [
              {
                "filename": "mvp-process-management.feature",
                "title": "Supervisor Process Management (MVP)",
                "content": "Feature: Supervisor Process Management (MVP)\n  The Supervisor spawns and monitors child processes.\n  It detects crashes and restarts children with basic retry logic.\n\n  Background:\n    Given the Supervisor process is running\n\n  Scenario: Spawn child processes on startup\n    When the Supervisor starts\n    Then it spawns the Meta-Agent process\n    And it spawns the Worker process\n    And both processes are in \"running\" state\n\n  Scenario: Detect child crash via waitpid\n    Given the Meta-Agent process is running\n    When the Meta-Agent process exits unexpectedly\n    Then the Supervisor detects the exit within 100ms\n    And the exit is logged with the process ID and exit code\n\n  Scenario: Restart crashed child\n    Given the Worker process has crashed\n    When the Supervisor detects the crash\n    Then it restarts the Worker process\n    And the new process is in \"running\" state\n    And the restart count is incremented\n\n  Scenario: Respect maximum retry limit\n    Given the Worker has crashed 5 times consecutively\n    When the Worker crashes again\n    Then the Supervisor does not restart the Worker\n    And the Worker state is set to \"failed\"\n    And an alert is logged\n\n  Scenario: Health API returns process status\n    Given both child processes are running\n    When a GET request is made to /health\n    Then the response status is 200\n    And the response body contains status for each child process\n    And each status includes \"pid\", \"state\", and \"uptime\"\n\n  Scenario: Graceful shutdown on SIGTERM\n    Given both child processes are running\n    When the Supervisor receives SIGTERM\n    Then it sends SIGTERM to all child processes\n    And it waits for children to exit\n    And it exits with code 0\n"
              }
            ]
          }
        },
        {
          "id": "dual-heartbeat",
          "name": "Dual Heartbeat",
          "type": "component",
          "layer": "supervisor-layer",
          "color": "purple",
          "icon": "ðŸ’“",
          "description": "Monitors both OpenCode instances independently via waitpid() + liveness probes. Instant crash detection (zero latency) â€” waitpid() returns the moment a child exits. Periodic liveness probe for hang detection â€” if no output for timeout_ms, treat as hung. Detects: exit, hang, OOM. If the Worker crashes â†’ recover using Meta-Agent's last plan. If the Meta-Agent crashes â†’ recover it first (higher priority), then it re-dispatches the Worker. Exponential backoff, max 5 retries â†’ alert Human Gate.",
          "tags": "[\"waitpid\",\"zero latency\",\"meta first\",\"worker second\",\"exponential backoff\"]",
          "sort_order": 22,
          "versions": {
            "mvp": {
              "content": "waitpid() loop for crash detection. Basic restart on exit. Retry counter with max limit. Log crash events.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "overview": {
              "content": "Monitors both OpenCode instances independently via waitpid() + liveness probes. Instant crash detection (zero latency) â€” waitpid() returns the moment a child exits. Periodic liveness probe for hang detection â€” if no output for timeout_ms, treat as hung. Detects: exit, hang, OOM. If Worker crashes â†’ recover using Meta-Agent's last plan. If Meta-Agent crashes â†’ recover it first (higher priority), then it re-dispatches Worker. Exponential backoff, max 5 retries â†’ alert Human Gate.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "human-gate",
          "name": "Human Gate",
          "type": "component",
          "layer": "supervisor-layer",
          "color": "pink",
          "icon": "â›³",
          "description": "Three modes: full-auto, approve-goals, approve-all. Plus write fence: dangerous ops require approval even in full-auto. Also surfaces escalation requests from the Worker. Write fence per-instance: Meta-Agent config mutations and Worker destructive ops can have independent gate policies. Gate mode is a runtime flag â€” switch between modes without restarting any process.",
          "tags": "[\"full-auto\",\"approve-goals\",\"approve-all\",\"write fence\",\"runtime flag\"]",
          "sort_order": 23,
          "versions": {
            "mvp": {
              "content": "Basic approval queue. CLI-based approve/reject. Write fence for destructive operations (hardcoded list). Block until approved or timeout.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "overview": {
              "content": "Three modes: full-auto, approve-goals, approve-all. Plus write fence: dangerous ops require approval even in full-auto. Also surfaces escalation requests from the Worker. Write fence per-instance: Meta-Agent config mutations and Worker destructive ops have independent gate policies. Gate mode is a runtime flag â€” switch between modes without restarting.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "v1": {
              "content": "Runtime mode switching (full-auto, approve-goals, approve-all). Per-instance gate policies. Escalation forwarding from Meta-Agent. Dashboard-embeddable approval UI.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "v2": {
              "content": "Configurable write fence per tool category. Approval delegation rules. Audit trail of all gate decisions. Timeout policies with configurable fallback actions.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {
            "mvp": [
              {
                "filename": "mvp-human-gate.feature",
                "title": "Human Gate (MVP)",
                "content": "Feature: Human Gate (MVP)\n  The Human Gate provides an approval queue for dangerous\n  operations and a write fence for destructive actions.\n\n  Background:\n    Given the Human Gate is running\n\n  Scenario: Block destructive operation for approval\n    Given the write fence includes \"database drop\" operations\n    When a task requests a database drop\n    Then the task is paused with status \"awaiting_approval\"\n    And the approval request is added to the queue\n\n  Scenario: Approve pending request\n    Given a task is paused awaiting approval\n    When a human approves the request\n    Then the task status changes to \"approved\"\n    And execution resumes\n\n  Scenario: Reject pending request\n    Given a task is paused awaiting approval\n    When a human rejects the request\n    Then the task status changes to \"rejected\"\n    And the task is aborted\n\n  Scenario: Timeout on unanswered request\n    Given a task has been awaiting approval for longer than the timeout\n    When the timeout expires\n    Then the task is aborted\n    And the timeout event is logged\n"
              }
            ]
          }
        },
        {
          "id": "fast-path-router",
          "name": "Fast Path Router",
          "type": "component",
          "layer": "supervisor-layer",
          "color": "lime",
          "icon": "âš¡",
          "description": "Rule engine (no LLM). Classifies tasks as fast, full, or gated. Scores incoming tasks by complexity signals: single-step? (e.g. \"format this file\"), no ambiguity? (clear input/output), no tool mutation needed? (current tools suffice). If all signals pass â†’ direct to Worker, skipping Meta-Agent. Meta-Agent notified after completion via State Store. Cuts latency and cost for simple tasks by ~50%. Configurable: fast_path: \"aggressive\" | \"conservative\" | \"off\". Can query User KG for context (\"does user prefer X for this type of task?\"). If fast-path task fails, re-routed through Meta-Agent.",
          "tags": "[\"fast\",\"full\",\"gated\",\"rule engine\",\"~50% savings\",\"new\"]",
          "sort_order": 24,
          "versions": {
            "mvp": {
              "content": "Simple rule engine: match task text against patterns (single verb, no conditionals, target file exists). Three outputs: fast, full, gated. Configurable threshold.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "overview": {
              "content": "Rule engine (no LLM). Classifies tasks as fast, full, or gated. Scores by complexity signals: single-step, no ambiguity, no tool mutation needed. Configurable: fast_path: \"aggressive\" | \"conservative\" | \"off\". Can query User KG for context. Cuts latency and cost ~50% for simple tasks. Fallback: failed fast-path tasks re-route through Meta-Agent.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        }
      ],
      "versions": {
        "overview": {
          "content": "The only immortal process. No LLM. Process manager + crash recovery + heartbeat. Exposes health API on :9100. Kill switch: /stop HTTP endpoint + SIGTERM handler. If it dies, systemd/Docker restarts it. Recovery sequence on crash detection: (1) Kill hung process if still alive. (2) Read last checkpoint from State Store. (3) Rebuild config via DSL. (4) Inject resume context via Context Rebuilder. (5) Respawn fresh OpenCode process (new PID, clean slate, resume prompt). (6) Exponential backoff if repeated failures, max 5 retries â†’ alert Human Gate.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      }
    },
    {
      "id": "task-router-layer",
      "name": "Task Router",
      "type": "layer",
      "layer": null,
      "color": "lime",
      "icon": "âš¡",
      "description": "Fast Path Decision Point â€” lightweight rule engine (no LLM) routes tasks by complexity: trivial goes direct to Worker, complex goes to Meta-Agent, dangerous requires human approval.",
      "tags": "[\"rule engine\",\"no llm\",\"classifier\"]",
      "sort_order": 30,
      "children": [
        {
          "id": "fast-path",
          "name": "Fast Path",
          "type": "component",
          "layer": "task-router-layer",
          "color": "lime",
          "icon": "âš¡",
          "description": "Rule engine says: single-step, unambiguous, existing tools suffice. Task goes directly to Worker. Meta-Agent notified post-completion via State Store. Flow: task â†’ classifier â†’ FAST â†’ Worker â†’ done â†’ State Store â†’ Meta-Agent reads.",
          "tags": "[\"trivial\",\"direct\",\"skip planner\"]",
          "sort_order": 31,
          "versions": {
            "overview": {
              "content": "Rule engine says: single-step, unambiguous, existing tools suffice. Task goes directly to Worker. Meta-Agent notified post-completion via State Store. Flow: task â†’ classifier â†’ FAST â†’ Worker â†’ done â†’ State Store â†’ Meta-Agent reads.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "full-path",
          "name": "Full Path",
          "type": "component",
          "layer": "task-router-layer",
          "color": "orange",
          "icon": "ðŸ§ ",
          "description": "Classifier says: multi-step, ambiguous, or needs tool changes. Task goes to Meta-Agent for decomposition. Normal planning loop. Flow: task â†’ classifier â†’ FULL â†’ Meta-Agent â†’ plan â†’ dispatch â†’ Worker â†’ State Store.",
          "tags": "[\"complex\",\"decomposition\",\"planning loop\"]",
          "sort_order": 32,
          "versions": {
            "overview": {
              "content": "Classifier says: multi-step, ambiguous, or needs tool changes. Task goes to Meta-Agent for decomposition. Normal planning loop. Flow: task â†’ classifier â†’ FULL â†’ Meta-Agent â†’ plan â†’ dispatch â†’ Worker â†’ State Store.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "gated-path",
          "name": "Gated Path",
          "type": "component",
          "layer": "task-router-layer",
          "color": "purple",
          "icon": "â›³",
          "description": "Classifier or Human Gate flags: destructive, high-cost, or security-sensitive. Task pauses for human approval before any routing. Flow: task â†’ classifier â†’ GATE â†’ Human Gate â†’ approve â†’ (fast or full path).",
          "tags": "[\"dangerous\",\"approval required\",\"security-sensitive\"]",
          "sort_order": 33,
          "versions": {
            "overview": {
              "content": "Classifier or Human Gate flags: destructive, high-cost, or security-sensitive. Task pauses for human approval. Flow: task â†’ classifier â†’ GATE â†’ Human Gate â†’ approve â†’ (fast or full path).",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        }
      ],
      "versions": {
        "overview": {
          "content": "Fast path decision point. Rule engine (no LLM) routes tasks by complexity. Classifier is NOT an LLM â€” it's a rule engine (regex + heuristics on task text). Signals: single verb (\"format\", \"lint\", \"rename\"), no conditional language, target file exists, current tools suffice. Configurable threshold: fast_path: \"aggressive\" | \"conservative\" | \"off\". Meta-Agent stays aware: fast-path completions logged to State Store. Fallback: if fast-path task fails, re-routed through Meta-Agent.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      }
    },
    {
      "id": "knowledge-graphs",
      "name": "Knowledge Graphs",
      "type": "layer",
      "layer": null,
      "color": "gold",
      "icon": "ðŸ§ ",
      "description": "Dual graph stores: User Knowledge Graph (domain context â€” people, projects, preferences) + RPG Code Graph (repo structure â€” files, modules, deps, data flows).",
      "tags": "[\"dual stores\",\"domain context\",\"repo structure\"]",
      "sort_order": 40,
      "children": [
        {
          "id": "user-knowledge-graph",
          "name": "User Knowledge Graph",
          "type": "store",
          "layer": "knowledge-graphs",
          "color": "gold",
          "icon": "ðŸ‘¤",
          "description": "A persistent graph of the user's world. Nodes are domain entities â€” people, projects, clients, teams, products, preferences, business rules, conventions, deadlines. Edges are typed relationships with metadata. This is not about code â€” it's about understanding who you are and what you care about so agents make contextually appropriate decisions. Entity types: person, project, org, team, preference, convention, deadline, stack, compliance, product, domain-concept, decision. Relationship types: OWNS, PREFERS, WORKS_WITH, HAS_CLIENT, USES_STACK, REQUIRES, CONVENTION, HAS_DEADLINE, DECIDED, DISLIKES. Populated by: (1) User directly â€” onboarding flow or dashboard edits. (2) Meta-Agent â€” infers entities from conversations and patterns over time. (3) Never by Worker â€” same injection-safety principle. Worker reads, never writes. Confidence layering: user-explicit (1.0) > meta-agent-inferred (0.8) > auto-extracted (0.6).",
          "tags": "[\"new\",\"persistent\",\"entity types\",\"relationship types\",\"confidence layering\"]",
          "sort_order": 41,
          "versions": {
            "mvp": {
              "content": "SQLite-backed entity store. Add/query entities with typed relationships. Basic traversal (1-hop neighbours). Manual entity creation via CLI or dashboard. Simple text search across entities.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "overview": {
              "content": "A persistent graph of the user's world. Nodes are domain entities â€” people, projects, clients, teams, products, preferences, business rules, conventions, deadlines. Edges are typed relationships with metadata. This is not about code â€” it's about understanding who you are and what you care about so agents make contextually appropriate decisions. Entity types: person, project, org, team, preference, convention, deadline, stack, compliance, product, domain-concept, decision. Relationship types: OWNS, PREFERS, WORKS_WITH, HAS_CLIENT, USES_STACK, REQUIRES, CONVENTION, HAS_DEADLINE, DECIDED, DISLIKES. Populated by: (1) User directly â€” onboarding flow or dashboard edits. (2) Meta-Agent â€” infers entities from conversations and patterns. (3) Never by Worker â€” injection safety. Confidence layering: user-explicit (1.0) > meta-agent-inferred (0.8) > auto-extracted (0.6). What it solves: Personalisation (\"Alice prefers typed SQL over ORMs\"), project awareness (\"acme-saas uses Next.js + Postgres, client needs SOC2\"), team context (\"Bob is backend lead, prefers PRs\"), decision memory (\"We decided JWT over sessions on Jan 15\"), convention enforcement (\"No ORMs, minimal comments, Tailwind\"), deadline awareness (Meta-Agent prioritises based on known deadlines).",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "v1": {
              "content": "Meta-Agent write access for inferred entities. Confidence layering (user-explicit 1.0 > meta-inferred 0.8). Multi-hop traversal queries. Convention enforcement lookups. Deadline awareness queries.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "v2": {
              "content": "Full graph query language. Temporal awareness (when was this preference set?). Conflict resolution for contradictory preferences. Export/import for portability. Dashboard entity editor.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {
            "mvp": [
              {
                "filename": "mvp-user-kg.feature",
                "title": "User Knowledge Graph (MVP)",
                "content": "Feature: User Knowledge Graph (MVP)\n  A persistent entity-relationship store for domain context:\n  people, projects, preferences, conventions, deadlines.\n\n  Background:\n    Given the User Knowledge Graph SQLite database exists\n\n  Scenario: Add an entity\n    When an entity is added with type \"person\" and name \"Alice\"\n    Then the entity exists in the graph with a unique ID\n    And it has type \"person\" and name \"Alice\"\n\n  Scenario: Add a relationship between entities\n    Given entities \"Alice\" (person) and \"acme-saas\" (project) exist\n    When a relationship \"OWNS\" is added from \"Alice\" to \"acme-saas\"\n    Then the edge exists with type \"OWNS\"\n    And it references both entities\n\n  Scenario: Query 1-hop neighbours\n    Given \"Alice\" has relationships to \"acme-saas\", \"Bob\", and \"minimal-comments\"\n    When querying neighbours of \"Alice\"\n    Then all 3 connected entities are returned\n    And each result includes the relationship type\n\n  Scenario: Search entities by text\n    Given entities \"Alice\", \"Bob\", and \"acme-saas\" exist\n    When searching for \"alice\"\n    Then the entity \"Alice\" is returned\n\n  Scenario: Add entity with metadata\n    When an entity is added with type \"preference\" name \"no-orms\" and metadata '{\"reason\": \"team decision\"}'\n    Then the entity exists with the metadata attached\n"
              }
            ]
          }
        },
        {
          "id": "rpg-code-graph",
          "name": "RPG Code Graph",
          "type": "store",
          "layer": "knowledge-graphs",
          "color": "emerald",
          "icon": "ðŸ—º",
          "description": "An RPG-style structural graph of the current codebase. Encodes file hierarchy, module boundaries, inter-module data flows, function signatures, class inheritance, and import dependencies. Inspired by Microsoft RPG/ZeroRepo (https://arxiv.org/abs/2509.16198). This is a code quality feature â€” it helps the Worker write structurally coherent code by understanding what exists, what depends on what, and where new code should go. Node types: module, file, function, class, interface, package, route, schema, test. Edge types: CONTAINS, IMPORTS, EXPORTS, DATA_FLOW, EXTENDS, IMPLEMENTS, DEPENDS_ON, TESTS, CALLS. Populated by: (1) Static analysis on init â€” AST parse via tree-sitter on repo load (~seconds for repos under 100K LoC). (2) Worker's Checkpointer â€” auto-updates after file edits (re-parse only changed files, diff old vs new, update edges incrementally). (3) Meta-Agent â€” can annotate with higher-level module boundaries and data flow intentions. Lightweight â€” no LLM needed for extraction. Query patterns: topo_order(module), data_flow(A,B), dependents(file), pattern(type,dir), where_to_add(capability).",
          "tags": "[\"new\",\"tree-sitter\",\"ast parsing\",\"disposable\",\"re-derivable\",\"query patterns\"]",
          "sort_order": 42,
          "versions": {
            "mvp": {
              "content": "Static analysis on repo load using tree-sitter. Build initial graph from imports, exports, class hierarchy. Basic queries: list files in module, show imports for file. SQLite-backed.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "overview": {
              "content": "An RPG-style structural graph of the current codebase. Encodes file hierarchy, module boundaries, inter-module data flows, function signatures, class inheritance, and import dependencies. Inspired by Microsoft RPG/ZeroRepo (arxiv.org/abs/2509.16198). This is a code quality feature â€” it helps the Worker write structurally coherent code. Node types: module, file, function, class, interface, package, route, schema, test. Edge types: CONTAINS, IMPORTS, EXPORTS, DATA_FLOW, EXTENDS, IMPLEMENTS, DEPENDS_ON, TESTS, CALLS. What it solves: Dependency awareness (Worker knows what imports what before editing), placement decisions (\"where should rate limiting go?\" â†’ traverse moduleâ†’fileâ†’function), topological code generation (build in dependency order), data flow understanding (inter-module edges), pattern consistency (existing patterns visible), blast radius estimation (Meta-Agent traverses deps). Implementation: (1) Initial build on repo load â€” tree-sitter AST parse, extract files/imports/exports/classes/functions, infer modules from directory structure, ~seconds for repos under 100K LoC. (2) Incremental update on edit â€” Checkpointer detects file-edit tool calls, re-parses only changed files, diffs old vs new, updates edges incrementally. (3) Query patterns â€” topo_order(module), data_flow(A,B), dependents(file), pattern(type,dir), where_to_add(capability).",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "v1": {
              "content": "Incremental updates via Checkpointer (re-parse only changed files). Dependency traversal (topo_order, dependents). Data flow edges between modules. Pattern queries.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "v2": {
              "content": "Full where_to_add capability suggestions. Blast radius estimation. Meta-Agent annotations. Multi-language AST support. Dashboard Repo Map visualization.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {
            "mvp": [
              {
                "filename": "mvp-code-graph.feature",
                "title": "RPG Code Graph (MVP)",
                "content": "Feature: RPG Code Graph (MVP)\n  Static analysis on repo load builds a structural graph of the\n  codebase: files, imports, exports, classes, functions.\n\n  Background:\n    Given a repository with source files exists\n\n  Scenario: Build initial graph from repo\n    When the Code Graph builder runs on the repository\n    Then nodes are created for each source file\n    And edges are created for import relationships\n    And the graph is stored in SQLite\n\n  Scenario: Extract function exports\n    Given a file \"auth/handler.ts\" exports function \"verifyToken\"\n    When the AST parser processes the file\n    Then a function node \"verifyToken\" exists\n    And an EXPORTS edge connects the file to the function\n\n  Scenario: Extract import relationships\n    Given \"api/routes.ts\" imports from \"auth/handler.ts\"\n    When the AST parser processes both files\n    Then an IMPORTS edge connects \"api/routes.ts\" to \"auth/handler.ts\"\n\n  Scenario: Infer modules from directory structure\n    Given the repository has directories \"auth/\", \"api/\", \"db/\"\n    When the Code Graph builder runs\n    Then module nodes are created for \"auth\", \"api\", \"db\"\n    And CONTAINS edges connect modules to their files\n\n  Scenario: Query files in a module\n    Given the module \"auth\" contains \"handler.ts\" and \"middleware.ts\"\n    When querying files in module \"auth\"\n    Then both files are returned\n"
              }
            ]
          }
        }
      ],
      "versions": {
        "overview": {
          "content": "Dual graph stores. User Knowledge Graph holds domain context (people, projects, preferences). RPG Code Graph holds repo structure (files, modules, deps, data flows). Three stores, three purposes: State Store (operational â€” what's happening now, prunable), User KG (domain â€” who you are, long-lived), Code Graph (repo structure â€” what the codebase looks like, disposable and re-derivable from code).",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      }
    },
    {
      "id": "dual-agents",
      "name": "Dual OpenCode Instances",
      "type": "layer",
      "layer": null,
      "color": "orange",
      "icon": "ðŸ§ ",
      "description": "Two stock OpenCode instances. Meta-Agent (Planner) uses cheap/fast model (Haiku/Sonnet), plans and dispatches. Worker (Executor) uses strong model (Sonnet/Opus), executes one phase at a time. They share no tools â€” isolation by design.",
      "tags": "[\"stock opencode\",\"dual instances\",\"tool isolation\"]",
      "sort_order": 50,
      "children": [
        {
          "id": "meta-agent",
          "name": "Meta-Agent (Planner)",
          "type": "component",
          "layer": "dual-agents",
          "color": "orange",
          "icon": "ðŸ§ ",
          "description": "Stock OpenCode, planning system prompt, cheap/fast model (Haiku/Sonnet). This instance never touches the codebase or external APIs directly. It only plans, evaluates, and dispatches. Tier-0: recovered first. If this is down, the Worker has no direction. Only internal tools, no injection surface. Traverses User KG to align plans with user preferences, deadlines, team context. Reads Code Graph to understand repo structure before decomposing coding tasks. Also handles escalation responses: reads Worker's request_clarification entries from State Store, reasons about them, and writes guidance back â€” which the Worker receives on its next checkpoint resume or via check_escalation_response tool. System prompt: \"You are a task planner. Use your tools to: read the goal queue, check worker status, decompose goals into tasks, dispatch tasks, evaluate results, and generate follow-up goals. You may also evolve the worker's tools and config when needed.\" The loop emerges from the prompt + tool availability.",
          "tags": "[\"tier-0\",\"10 internal tools\",\"reads/writes user kg\",\"reads code graph\",\"haiku/sonnet\",\"new\"]",
          "sort_order": 51,
          "versions": {
            "mvp": {
              "content": "Single OpenCode instance with planning system prompt. Read goal queue, decompose into sub-tasks, dispatch to Worker via State Store. Read Worker progress from checkpoints. Basic goal â†’ task decomposition.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "overview": {
              "content": "Stock OpenCode, planning system prompt, cheap/fast model (Haiku/Sonnet). This instance never touches the codebase or external APIs directly. It only plans, evaluates, and dispatches. Tier-0: recovered first. If this is down, the Worker has no direction. Only internal tools, no injection surface. Traverses User KG to align plans with user preferences, deadlines, team context. Reads Code Graph to understand repo structure before decomposing coding tasks. Also handles escalation responses: reads Worker's request_clarification entries from State Store, reasons about them, and writes guidance back. System prompt: \"You are a task planner. Use your tools to: read the goal queue, check worker status, decompose goals into tasks, dispatch tasks, evaluate results, and generate follow-up goals. You may also evolve the worker's tools and config when needed.\" The loop emerges from the prompt + tool availability. How Meta-Agent uses both graphs: Before planning â€” \"What stack? Deadlines? Preferences?\" Before decomposing â€” \"Which modules? Dependency order? Blast radius?\" Task dispatch enrichment â€” includes relevant KG + Code Graph context in Worker's task prompt. Tool selection â€” User KG says \"prefers Brave over Google\" â†’ configures proxy. Knowledge curation â€” writes inferred preferences to User KG. Self-evolution: tool discovery via tool_registry.search, config mutation via typed builder DSL (not raw JSON), sub-goal generation, prompt evolution based on observed results. Guardrails: budget limits, scope limits, allowed tool categories, model whitelist.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "v1": {
              "content": "Phase-locked BDD/TDD dispatch pipeline. Gate verification between phases. Escalation response handling. User KG reads for planning context. Code Graph reads for repo-aware decomposition.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "v2": {
              "content": "Self-evolution: tool discovery + hot-swap via proxy_admin. Config mutation via DSL. Prompt evolution based on observed results. Knowledge curation â€” write inferred preferences to User KG. Budget and scope guardrails.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {
            "mvp": [
              {
                "filename": "mvp-planning-loop.feature",
                "title": "Meta-Agent Planning Loop (MVP)",
                "content": "Feature: Meta-Agent Planning Loop (MVP)\n  The Meta-Agent reads goals, decomposes them into tasks,\n  and dispatches work to the Worker via the State Store.\n\n  Background:\n    Given the Meta-Agent is running with a planning system prompt\n    And the State Store is accessible\n\n  Scenario: Read next goal from queue\n    Given the goal queue contains \"Build user authentication\"\n    When the Meta-Agent checks the goal queue\n    Then it receives the goal \"Build user authentication\"\n    And the goal status is set to \"in-progress\"\n\n  Scenario: Decompose goal into tasks\n    Given the Meta-Agent has received the goal \"Build user authentication\"\n    When it decomposes the goal\n    Then the State Store contains at least 2 sub-tasks\n    And each sub-task has a description and ordering\n\n  Scenario: Dispatch task to Worker\n    Given a sub-task \"Create login endpoint\" exists in the State Store\n    When the Meta-Agent dispatches the task\n    Then the task status is set to \"dispatched\"\n    And the task includes a description and success criteria\n\n  Scenario: Read Worker progress\n    Given a task has been dispatched to the Worker\n    When the Meta-Agent checks Worker progress\n    Then it receives the latest checkpoint for that task\n    And the checkpoint includes tool calls made and their results\n\n  Scenario: Complete goal when all tasks done\n    Given all sub-tasks for a goal are in \"complete\" status\n    When the Meta-Agent evaluates the goal\n    Then the goal status is set to \"complete\"\n    And the Meta-Agent reads the next goal from the queue\n"
              }
            ]
          }
        },
        {
          "id": "worker",
          "name": "Worker (Executor)",
          "type": "component",
          "layer": "dual-agents",
          "color": "cyan",
          "icon": "âš¡",
          "description": "Stock OpenCode, execution system prompt, strong model (Sonnet/Opus). Tier-1, ephemeral, no fork. Lower stability priority â€” if it crashes, the Meta-Agent re-dispatches. Treated as ephemeral and replaceable. On recovery, the agent continues without knowing it crashed â€” the Context Rebuilder injects a resume prompt that makes it look like a natural continuation. External tools, sanitiser required. Reads User KG to respect user preferences during execution (naming conventions, tech choices). Traverses Code Graph to write structurally coherent code (dependency-aware edits, correct placement). Has two escalation tools: request_clarification to pause and ask the planner for guidance, and check_escalation_response to poll for an answer. System prompt: \"If you're uncertain about scope, direction, or trade-offs, use request_clarification. Don't guess â€” ask.\" Receives tasks as structured system prompt injections: phase, task, constraints, forbidden_actions, available_tools, success_criteria. Single-phase isolation: the Worker sees \"Write failing step tests for this feature file. DO NOT implement any production code.\" It literally cannot skip ahead because it doesn't know what \"ahead\" is. The forbidden_actions field explicitly lists what it must not do (e.g. [\"create production files\", \"modify existing src/\", \"run tests in watch mode\"]).",
          "tags": "[\"tier-1\",\"dynamic tools\",\"reads user kg\",\"reads code graph\",\"sanitiser required\",\"ephemeral\",\"no fork\",\"sonnet/opus\",\"new\"]",
          "sort_order": 52,
          "versions": {
            "mvp": {
              "content": "Single OpenCode instance with execution system prompt. Receive task from State Store, execute with available tools, report results. Basic tool access via MCP proxy.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "overview": {
              "content": "Stock OpenCode, execution system prompt, strong model (Sonnet/Opus). Tier-1, ephemeral, no fork. Lower stability priority â€” if it crashes, the Meta-Agent re-dispatches. Treated as ephemeral and replaceable. On recovery, the agent continues without knowing it crashed â€” the Context Rebuilder injects a resume prompt that makes it look like a natural continuation. External tools, sanitiser required. Reads User KG to respect user preferences during execution. Traverses Code Graph for structurally coherent code. Has escalation tools: request_clarification and check_escalation_response. System prompt: \"If you're uncertain about scope, direction, or trade-offs, use request_clarification. Don't guess â€” ask.\" Receives tasks as structured injections: phase, task, constraints, forbidden_actions, available_tools, success_criteria. Single-phase isolation: Worker sees only current phase, never what comes next. Example forbidden_actions: [\"create production files\", \"modify existing src/\", \"run tests in watch mode\"]. The Worker literally cannot skip ahead because it doesn't know what \"ahead\" is.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "v1": {
              "content": "Phase-locked execution (single phase per dispatch, forbidden_actions enforcement). Escalation tools (request_clarification, check_escalation_response). User KG reads for preference-aware execution. Code Graph reads for structural coherence.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "v2": {
              "content": "Context-aware resume after crash (transparent to agent). Dynamic tool manifest â€” handles hot-swap mid-session. Confidence scoring on outputs. Full sanitiser integration on all external I/O.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {
            "mvp": [
              {
                "filename": "mvp-task-execution.feature",
                "title": "Worker Task Execution (MVP)",
                "content": "Feature: Worker Task Execution (MVP)\n  The Worker receives tasks from the State Store and executes\n  them using available tools via the MCP proxy.\n\n  Background:\n    Given the Worker is running with an execution system prompt\n    And the MCP proxy is accessible with at least one tool\n\n  Scenario: Receive dispatched task\n    Given a task \"Create login endpoint\" is in \"dispatched\" status\n    When the Worker checks for pending tasks\n    Then it receives the task with description and constraints\n\n  Scenario: Execute task with tools\n    Given the Worker has received a task\n    When it executes the task\n    Then it makes at least one tool call via the MCP proxy\n    And each tool call is logged to the State Store\n\n  Scenario: Report task completion\n    Given the Worker has finished executing a task\n    When it reports results\n    Then the task status is set to \"complete\"\n    And the result summary is written to the State Store\n\n  Scenario: Handle tool call failure\n    Given the Worker is executing a task\n    When a tool call returns an error\n    Then the Worker logs the error\n    And it attempts an alternative approach or reports failure\n\n  Scenario: Operate within provided constraints\n    Given the Worker receives a task with forbidden_actions [\"delete files\"]\n    When it executes the task\n    Then it does not call any tool that would delete files\n"
              }
            ]
          }
        },
        {
          "id": "goal-queue",
          "name": "goal_queue",
          "type": "component",
          "layer": "dual-agents",
          "color": "orange",
          "icon": "ðŸ“‹",
          "description": "push, pop, peek, reprioritise â€” manages the persistent goal queue.",
          "tags": "[\"meta-agent tool\"]",
          "sort_order": 53,
          "versions": {
            "overview": {
              "content": "push, pop, peek, reprioritise â€” manages the persistent goal queue.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "state-reader",
          "name": "state_reader",
          "type": "component",
          "layer": "dual-agents",
          "color": "orange",
          "icon": "ðŸ“–",
          "description": "get_checkpoint, get_task_log, get_escalations â€” reads Worker's progress.",
          "tags": "[\"meta-agent tool\"]",
          "sort_order": 54,
          "versions": {
            "overview": {
              "content": "get_checkpoint, get_task_log, get_escalations â€” reads Worker's progress.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "worker-control",
          "name": "worker_control",
          "type": "component",
          "layer": "dual-agents",
          "color": "orange",
          "icon": "ðŸ”§",
          "description": "dispatch, abort, respond_escalation â€” sends phase-locked work to Worker. Dispatch includes phase, forbidden_actions, success_criteria.",
          "tags": "[\"meta-agent tool\",\"phase-locked\"]",
          "sort_order": 55,
          "versions": {
            "overview": {
              "content": "dispatch, abort, respond_escalation â€” sends phase-locked work to Worker. Dispatch includes phase, forbidden_actions, success_criteria.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "proxy-admin",
          "name": "proxy_admin",
          "type": "component",
          "layer": "dual-agents",
          "color": "orange",
          "icon": "ðŸ“¡",
          "description": "register, deregister, list â€” mutates Worker's tool manifest at runtime.",
          "tags": "[\"meta-agent tool\",\"hot-swap\"]",
          "sort_order": 56,
          "versions": {
            "overview": {
              "content": "register, deregister, list â€” mutates Worker's tool manifest at runtime.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "config-mutator",
          "name": "config_mutator",
          "type": "component",
          "layer": "dual-agents",
          "color": "orange",
          "icon": "âš™",
          "description": "update_prompt, update_model, update_agents â€” evolves Worker's config via typed builder DSL. Validated, versioned, rollback-safe. Not raw JSON editing.",
          "tags": "[\"meta-agent tool\",\"dsl\",\"rollback-safe\"]",
          "sort_order": 57,
          "versions": {
            "overview": {
              "content": "update_prompt, update_model, update_agents â€” evolves Worker's config via typed builder DSL. Validated, versioned, rollback-safe.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "tool-registry",
          "name": "tool_registry",
          "type": "component",
          "layer": "dual-agents",
          "color": "orange",
          "icon": "ðŸ”",
          "description": "search, inspect, install â€” discovers new MCP servers from a catalogue.",
          "tags": "[\"meta-agent tool\",\"discovery\"]",
          "sort_order": 58,
          "versions": {
            "overview": {
              "content": "search, inspect, install â€” discovers new MCP servers from a catalogue.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "user-kg-read-meta",
          "name": "user_kg_read (Meta)",
          "type": "component",
          "layer": "dual-agents",
          "color": "gold",
          "icon": "ðŸ‘¤",
          "description": "query, traverse, search â€” Meta-Agent reads User KG for planning context.",
          "tags": "[\"meta-agent tool\",\"new\"]",
          "sort_order": 59,
          "versions": {
            "overview": {
              "content": "query, traverse, search â€” Meta-Agent reads User KG for planning context.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "user-kg-write-meta",
          "name": "user_kg_write (Meta)",
          "type": "component",
          "layer": "dual-agents",
          "color": "gold",
          "icon": "âœ",
          "description": "add_entity, add_edge, annotate â€” Meta-Agent writes inferred entities to User KG.",
          "tags": "[\"meta-agent tool\",\"new\"]",
          "sort_order": 60,
          "versions": {
            "overview": {
              "content": "add_entity, add_edge, annotate â€” Meta-Agent writes inferred entities to User KG.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "code-graph-read-meta",
          "name": "code_graph_read (Meta)",
          "type": "component",
          "layer": "dual-agents",
          "color": "emerald",
          "icon": "ðŸ—º",
          "description": "expand, path, topo_order â€” Meta-Agent reads Code Graph for repo-aware decomposition.",
          "tags": "[\"meta-agent tool\",\"new\"]",
          "sort_order": 61,
          "versions": {
            "overview": {
              "content": "expand, path, topo_order â€” Meta-Agent reads Code Graph for repo-aware decomposition.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "code-graph-write-meta",
          "name": "code_graph_write (Meta)",
          "type": "component",
          "layer": "dual-agents",
          "color": "emerald",
          "icon": "âœ",
          "description": "annotate_module, set_data_flow â€” Meta-Agent annotates Code Graph with module boundaries and data flow intentions.",
          "tags": "[\"meta-agent tool\",\"new\"]",
          "sort_order": 62,
          "versions": {
            "overview": {
              "content": "annotate_module, set_data_flow â€” Meta-Agent annotates Code Graph with module boundaries and data flow intentions.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "request-clarification",
          "name": "request_clarification",
          "type": "component",
          "layer": "dual-agents",
          "color": "teal",
          "icon": "ðŸ™‹",
          "description": "Writes question + context snapshot to State Store. Sets task status to paused:awaiting_guidance. Worker halts current execution and waits.",
          "tags": "[\"worker tool\",\"escalation\"]",
          "sort_order": 63,
          "versions": {
            "overview": {
              "content": "Writes question + context snapshot to State Store. Sets task status to paused:awaiting_guidance. Worker halts current execution and waits.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "check-escalation-response",
          "name": "check_escalation_response",
          "type": "component",
          "layer": "dual-agents",
          "color": "teal",
          "icon": "ðŸ“¨",
          "description": "Polls State Store for Meta-Agent's response. Returns guidance or still_pending. Worker resumes when guidance arrives.",
          "tags": "[\"worker tool\",\"escalation\"]",
          "sort_order": 64,
          "versions": {
            "overview": {
              "content": "Polls State Store for Meta-Agent's response. Returns guidance or still_pending. Worker resumes when guidance arrives.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "user-kg-read-worker",
          "name": "user_kg_read (Worker)",
          "type": "component",
          "layer": "dual-agents",
          "color": "gold",
          "icon": "ðŸ‘¤",
          "description": "Read-only. No writes (injection safety). Worker reads preferences but cannot poison the knowledge graph even if fully compromised.",
          "tags": "[\"worker tool\",\"read-only\",\"new\"]",
          "sort_order": 65,
          "versions": {
            "overview": {
              "content": "Read-only. No writes (injection safety). Worker reads preferences but cannot poison the knowledge graph.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "code-graph-read-worker",
          "name": "code_graph_read (Worker)",
          "type": "component",
          "layer": "dual-agents",
          "color": "emerald",
          "icon": "ðŸ—º",
          "description": "Read-only. Checkpointer writes on Worker's behalf after file edits trigger AST re-parse.",
          "tags": "[\"worker tool\",\"read-only\",\"new\"]",
          "sort_order": 66,
          "versions": {
            "overview": {
              "content": "Read-only. Checkpointer writes on Worker's behalf after file edits trigger AST re-parse.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        }
      ],
      "versions": {
        "overview": {
          "content": "Two stock OpenCode instances. Meta-Agent (Planner) uses cheap model (Haiku/Sonnet), plans and dispatches. Worker (Executor) uses strong model (Sonnet/Opus), executes one phase at a time. Why two instances? (1) Separation of concerns: planning and execution have different tool sets, models, cost profiles, and risk levels. (2) Blast radius: a prompt injection in the Worker can't reach the Planner â€” they share no tools or MCP connection. (3) Independent recovery: Worker can crash and be re-dispatched without losing Meta-Agent's plan state. (4) Cost optimisation: Planner uses cheap model, Worker uses capable model. (5) Dogfooding: you build one runtime, not two systems. Both instances use the same config DSL, proxy, and checkpoint infra.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      }
    },
    {
      "id": "escalation-flow",
      "name": "Escalation Flow",
      "type": "layer",
      "layer": null,
      "color": "teal",
      "icon": "ðŸ™‹",
      "description": "Worker â†” Meta-Agent communication via shared state. Worker hits ambiguity â†’ calls request_clarification({question, context, options}) â†’ State Store records escalation â†’ Worker pauses â†’ Meta-Agent picks it up on next cycle â†’ reasons â†’ responds via worker_control.respond_escalation â†’ State Store updates â†’ Worker calls check_escalation_response â†’ receives guidance â†’ resumes. Timeout handling: if Meta-Agent does not respond within escalation_timeout_ms, Worker can (a) proceed with best guess, (b) abort, or (c) escalate to Human Gate. Policy set in Worker system prompt.",
      "tags": "[\"async\",\"no blocking rpc\",\"structured payload\"]",
      "sort_order": 60,
      "children": [],
      "versions": {
        "overview": {
          "content": "Worker â†” Meta-Agent communication via shared state. Escalation sequence: Worker hits ambiguity â†’ calls request_clarification({question, context, options}) â†’ State Store records with status pending â†’ Worker pauses (returns control to idle loop) â†’ Meta-Agent's state_reader.get_escalations() picks it up â†’ Meta-Agent reasons â†’ calls worker_control.respond_escalation({task_id, guidance}) â†’ State Store updates to resolved â†’ Worker calls check_escalation_response() â†’ receives guidance â†’ resumes. Timeout: if no response within escalation_timeout_ms, Worker can: (a) proceed_best_guess, (b) abort, or (c) escalate_to_human. Design: Worker stays isolated (writes to State Store, not to Meta-Agent directly). Async by design (no blocking RPC). Structured payload: {question, context_snapshot, suggested_options[], urgency}. Crash safety: Checkpointer snapshots escalation state.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      }
    },
    {
      "id": "shared-state",
      "name": "Shared State Store",
      "type": "layer",
      "layer": null,
      "color": "blue",
      "icon": "ðŸ’¾",
      "description": "The Bridge â€” SQLite WAL / Postgres. Goals, tasks, tool logs, checkpoints, escalations. Both instances communicate by sharing a database, not a connection.",
      "tags": "[\"sqlite wal\",\"postgres\",\"append-only\"]",
      "sort_order": 70,
      "children": [
        {
          "id": "state-store",
          "name": "State Store",
          "type": "store",
          "layer": "shared-state",
          "color": "blue",
          "icon": "ðŸ’¾",
          "description": "Append-only log that both instances read/write. The Meta-Agent writes goals and reads results. The Worker's Checkpointer writes tool call logs and progress. This is how the two OpenCode instances communicate without direct coupling â€” they share a database, not a connection. Also stores escalation records (question, context, response, status) and fast-path completion records so the Meta-Agent stays aware of tasks it didn't plan. Dashboard reads everything here.",
          "tags": "[\"checkpointer\",\"context rebuilder\",\"crash recovery\"]",
          "sort_order": 71,
          "versions": {
            "mvp": {
              "content": "SQLite WAL database with tables for goals, tasks, and tool_logs. Basic CRUD operations. Both agents read/write via simple SQL. No pruning, no optimization.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "overview": {
              "content": "Append-only log that both instances read/write. The Meta-Agent writes goals and reads results. The Worker's Checkpointer writes tool call logs and progress. This is how the two OpenCode instances communicate without direct coupling â€” they share a database, not a connection. Also stores escalation records (question, context, response, status) and fast-path completion records so the Meta-Agent stays aware of tasks it didn't plan. Dashboard reads everything here.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "v1": {
              "content": "Add checkpoints table, escalation records, fast-path completion records. Context rebuilder queries. Pruning policy (keep last N days). Indexes for common query patterns.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "v2": {
              "content": "SSE/WebSocket push for live dashboard updates. Postgres option for multi-machine deployments. Full audit trail with retention policies. Query optimization for dashboard views.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {
            "mvp": [
              {
                "filename": "mvp-shared-state.feature",
                "title": "Shared State Store (MVP)",
                "content": "Feature: Shared State Store (MVP)\n  The State Store is a SQLite WAL database that both agents\n  read and write. It stores goals, tasks, and tool logs.\n\n  Background:\n    Given the State Store SQLite database exists\n\n  Scenario: Create a goal\n    When a goal \"Build user authentication\" is inserted\n    Then the goal exists with status \"pending\"\n    And the goal has a created_at timestamp\n\n  Scenario: Create tasks for a goal\n    Given a goal exists with id \"goal-1\"\n    When tasks are inserted for goal \"goal-1\"\n    Then each task references the parent goal\n    And each task has status \"pending\" and an ordering index\n\n  Scenario: Log a tool call\n    Given a task exists with id \"task-1\"\n    When a tool call log is inserted with tool \"filesystem\", args hash, and result hash\n    Then the tool log exists with a timestamp\n    And the tool log references \"task-1\"\n\n  Scenario: Both agents can read/write concurrently\n    Given the Meta-Agent is writing a goal\n    And the Worker is writing a tool log\n    Then both writes succeed without conflict\n    And the WAL journal mode handles concurrent access\n\n  Scenario: Query task status by goal\n    Given a goal has 3 tasks with statuses \"complete\", \"in-progress\", \"pending\"\n    When querying tasks for that goal\n    Then all 3 tasks are returned with their statuses\n"
              }
            ]
          }
        },
        {
          "id": "checkpointer",
          "name": "Checkpointer",
          "type": "component",
          "layer": "shared-state",
          "color": "blue",
          "icon": "ðŸ“¸",
          "description": "Taps Worker's Proxy. Writes after every tool response: task ID, tool name, args, result hash, timestamp, plan summary. Also snapshots escalation state so crash recovery can restore a paused-and-waiting Worker correctly. If tool was a file edit, also triggers AST re-parse and Code Graph update. Strategy: tool results are facts; LLM reasoning can be re-derived. So we save the facts (tool call + result) and let the Context Rebuilder regenerate the reasoning frame on recovery. Runs async â€” doesn't block the agent. The proxy fires-and-forgets to the checkpointer; the Worker never waits for a checkpoint write to complete.",
          "tags": "[\"async\",\"fire-and-forget\",\"non-blocking\",\"code graph update\"]",
          "sort_order": 72,
          "versions": {
            "mvp": {
              "content": "Intercept tool responses from Worker proxy. Write task_id, tool_name, args_hash, result_hash, timestamp to State Store. Fire-and-forget (async, non-blocking).",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "overview": {
              "content": "Taps Worker's Proxy. Writes after every tool response: task ID, tool name, args, result hash, timestamp, plan summary. Also snapshots escalation state so crash recovery can restore a paused-and-waiting Worker correctly. If tool was a file edit, triggers AST re-parse and Code Graph update. Strategy: tool results are facts; LLM reasoning can be re-derived. So we save the facts and let the Context Rebuilder regenerate the reasoning frame on recovery. Runs async â€” the proxy fires-and-forgets; the Worker never waits for a checkpoint write to complete.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "v1": {
              "content": "Escalation state snapshots. File-edit detection triggering Code Graph AST re-parse. Plan summary snapshots for context rebuilder. Idempotency markers for crash recovery.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "v2": {
              "content": "Configurable checkpoint granularity. Compressed checkpoint storage. Checkpoint pruning with retention policy. Metrics on checkpoint write latency.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {
            "mvp": [
              {
                "filename": "mvp-checkpointing.feature",
                "title": "Checkpointer (MVP)",
                "content": "Feature: Checkpointer (MVP)\n  The Checkpointer taps the Worker's MCP proxy and records\n  every tool call for crash recovery and progress tracking.\n\n  Background:\n    Given the Checkpointer is attached to the Worker's MCP proxy\n    And the State Store is accessible\n\n  Scenario: Record tool call after response\n    Given the Worker calls the \"filesystem\" tool with args \"read file.ts\"\n    When the tool returns a successful response\n    Then the Checkpointer writes a record to the State Store\n    And the record includes task_id, tool_name, args_hash, result_hash, and timestamp\n\n  Scenario: Non-blocking operation\n    Given the Worker is executing a task\n    When a tool call completes\n    Then the Checkpointer writes asynchronously\n    And the Worker does not wait for the checkpoint write\n\n  Scenario: Maintain ordering of tool calls\n    Given the Worker makes 3 sequential tool calls\n    When all 3 are checkpointed\n    Then the records are ordered by timestamp\n    And each has a sequential index within the task\n\n  Scenario: Handle write failure gracefully\n    Given the State Store is temporarily unavailable\n    When the Checkpointer attempts to write\n    Then it retries with backoff\n    And the Worker execution is not affected\n"
              }
            ]
          }
        },
        {
          "id": "context-rebuilder",
          "name": "Context Rebuilder",
          "type": "component",
          "layer": "shared-state",
          "color": "blue",
          "icon": "ðŸ“",
          "description": "On crash recovery of either instance: generates resume prompt from compressed checkpoint + relevant graph context. For Worker: \"you were doing X, completed Y, next step Z\". For Meta-Agent: \"current goal is X, worker status is Y, pending goals are Z\". If Worker was in paused:awaiting_guidance state, resume prompt includes the escalation question and any response received while it was down. Lossy by design. You can't clone LLM hidden state â€” it's non-serialisable. This is like a save game, not a VM snapshot. The rebuilt context is \"good enough\" â€” the agent continues without knowing it crashed, picking up from the last checkpoint with a compressed summary of what came before.",
          "tags": "[\"lossy by design\",\"save game\",\"resume prompt\"]",
          "sort_order": 73,
          "versions": {
            "mvp": {
              "content": "Read last checkpoint from State Store. Generate basic resume prompt: \"you were doing X, completed Y, next step Z\". Inject as system prompt on respawn.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "overview": {
              "content": "On crash recovery of either instance: generates resume prompt from compressed checkpoint + relevant graph context. For Worker: \"you were doing X, completed Y, next step Z\". For Meta-Agent: \"current goal is X, worker status is Y, pending goals are Z\". If Worker was in paused:awaiting_guidance state, resume prompt includes the escalation question and any response received while it was down. Lossy by design. You can't clone LLM hidden state â€” it's non-serialisable. This is like a save game, not a VM snapshot.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "v1": {
              "content": "Include relevant User KG context in resume prompt. Include Code Graph context for coding tasks. Handle paused:awaiting_guidance state.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "v2": {
              "content": "Compressed multi-checkpoint summaries. Relevance-ranked context selection. Token budget management for resume prompts.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {
            "mvp": [
              {
                "filename": "mvp-context-rebuild.feature",
                "title": "Context Rebuilder (MVP)",
                "content": "Feature: Context Rebuilder (MVP)\n  On crash recovery, the Context Rebuilder generates a resume\n  prompt from the last checkpoint so the agent can continue.\n\n  Background:\n    Given the State Store contains checkpoints for a crashed agent\n\n  Scenario: Generate resume prompt for Worker\n    Given the Worker crashed mid-task on task \"Create login endpoint\"\n    And the last checkpoint shows 3 completed tool calls\n    When the Context Rebuilder generates a resume prompt\n    Then the prompt includes \"you were doing: Create login endpoint\"\n    And it lists the 3 completed tool calls with their results\n    And it states the next expected action\n\n  Scenario: Generate resume prompt for Meta-Agent\n    Given the Meta-Agent crashed while processing goal \"Build auth\"\n    And the goal has 5 tasks, 2 completed and 1 in-progress\n    When the Context Rebuilder generates a resume prompt\n    Then the prompt includes the current goal state\n    And it lists completed and pending tasks\n    And it states the current Worker status\n\n  Scenario: Handle empty checkpoint\n    Given no checkpoints exist for the crashed agent\n    When the Context Rebuilder generates a resume prompt\n    Then it produces a minimal prompt with no prior context\n    And the agent starts fresh\n"
              }
            ]
          }
        }
      ],
      "versions": {
        "overview": {
          "content": "SQLite WAL / Postgres. Goals, tasks, tool logs, checkpoints, escalations. The bridge between both instances â€” they share a database, not a connection. Context preservation: What IS saved â€” task ID + current step index, tool call log (name, args, result hash), plan summary (goal queue snapshot), goal queue pointer, timestamps, escalation state. What is NOT saved â€” LLM hidden state (non-serialisable), full conversation history (too large), in-flight reasoning (ephemeral by nature). Tool results are facts; LLM reasoning can be re-derived.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      }
    },
    {
      "id": "mcp-proxies",
      "name": "MCP Proxies",
      "type": "layer",
      "layer": null,
      "color": "orange",
      "icon": "â‡„",
      "description": "Tool proxy layer for both agent instances. Meta-Agent gets static manifest (10 internal tools, no sanitiser). Worker gets dynamic manifest (hot-swappable, sanitiser required, circuit breaker).",
      "tags": "[\"static manifest\",\"dynamic manifest\",\"hot-swappable\"]",
      "sort_order": 80,
      "children": [
        {
          "id": "mcp-proxy-meta",
          "name": "MCP Proxy â€” Meta-Agent",
          "type": "component",
          "layer": "mcp-proxies",
          "color": "orange",
          "icon": "â‡„",
          "description": "Hosts 10 planning tools (6 planning + 4 graph). These are your custom MCP servers â€” small, stable, purpose-built. No external API calls, no injection risk.",
          "tags": "[\"static\",\"no sanitiser\",\"low risk\"]",
          "sort_order": 81,
          "versions": {
            "mvp": {
              "content": "Static MCP server hosting goal_queue, state_reader, worker_control tools. Simple stdio transport. No hot-swap needed.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "overview": {
              "content": "Hosts 10 planning tools (6 planning + 4 graph). These are your custom MCP servers â€” small, stable, purpose-built. No external API calls, no injection risk.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "mcp-proxy-worker",
          "name": "MCP Proxy â€” Worker",
          "type": "component",
          "layer": "mcp-proxies",
          "color": "cyan",
          "icon": "â‡„",
          "description": "Hosts all external-facing tools + escalation + graph reads. Dynamic manifest â€” the Meta-Agent's proxy_admin tool adds/removes servers here at runtime. All responses pass through the Sanitiser. Health & circuit breaker: heartbeats downstream servers; dead endpoints auto-removed from manifest, Meta-Agent notified via State Store so it can find replacements.",
          "tags": "[\"sanitiser required\",\"hot-swappable\",\"checkpoint tap\",\"circuit breaker\"]",
          "sort_order": 82,
          "versions": {
            "mvp": {
              "content": "MCP proxy with configurable tool list. Route tool calls to downstream servers. Pass responses through sanitiser. Basic health check on downstream servers.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "overview": {
              "content": "Hosts all external-facing tools + escalation + graph reads. Dynamic manifest â€” Meta-Agent's proxy_admin adds/removes servers at runtime. All responses pass through Sanitiser. Health & circuit breaker: heartbeats downstream servers; dead endpoints auto-removed from manifest, Meta-Agent notified via State Store so it can find replacements.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        }
      ],
      "versions": {
        "overview": {
          "content": "Tool proxy layer. Meta-Agent gets static manifest (10 internal tools, no sanitiser, low risk). Worker gets dynamic manifest (hot-swappable, sanitiser required, circuit breaker, checkpoint tap).",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      }
    },
    {
      "id": "security-sandbox",
      "name": "Security Sandbox",
      "type": "layer",
      "layer": null,
      "color": "red",
      "icon": "ðŸ›¡",
      "description": "3-stage sanitiser pipeline (Worker proxy only). Regex heuristics â†’ structural strip (role tags, cap length) â†’ optional LLM classifier. Fail-closed. Isolated subprocess. Scans inbound responses (injection defence) AND outbound tool args (prevents data exfiltration via tricked agent).",
      "tags": "[\"fail-closed\",\"isolated subprocess\",\"bidirectional\"]",
      "sort_order": 90,
      "children": [
        {
          "id": "sanitiser",
          "name": "3-Stage Sanitiser",
          "type": "component",
          "layer": "security-sandbox",
          "color": "red",
          "icon": "ðŸ›¡",
          "description": "Sits between Worker's Proxy and downstream servers. Stage 1: Heuristic regex for common injection patterns. Stage 2: Structural strip (remove role tags, cap response length). Stage 3: Optional LLM classifier for sophisticated detection. The Meta-Agent's proxy does NOT need a sanitiser â€” its tools are all internal, no external input. Isolated subprocess. Fail-closed. Scans inbound responses (injection defence) and outbound tool args (prevents data exfiltration via a tricked agent â€” e.g. an injected prompt that encodes secrets into a search query). Injection events visible in dashboard Security Events panel.",
          "tags": "[\"3-stage\",\"fail-closed\",\"isolated subprocess\",\"bidirectional\"]",
          "sort_order": 91,
          "versions": {
            "mvp": {
              "content": "Regex-based heuristic scanner for common injection patterns. Structural strip (remove role tags, cap response length). Pass/block verdict on each tool response. Logging to State Store.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "overview": {
              "content": "Sits between Worker's Proxy and downstream servers. Stage 1: Heuristic regex for common injection patterns. Stage 2: Structural strip (remove role tags, cap response length). Stage 3: Optional LLM classifier for sophisticated detection. The Meta-Agent's proxy does NOT need a sanitiser â€” its tools are all internal, no external input. Isolated subprocess. Fail-closed. Scans inbound responses (injection defence) and outbound tool args (prevents data exfiltration â€” e.g. an injected prompt encoding secrets into a search query). Injection events visible in dashboard Security Events panel.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "v1": {
              "content": "Outbound scanning (prevent data exfiltration via tool args). Configurable rule sets per tool. Injection frequency tracking. Auto-disable tools exceeding threshold. Dashboard integration.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            },
            "v2": {
              "content": "Optional LLM classifier stage. Adaptive rules based on observed attack patterns. Per-tool confidence scoring. Full audit trail with payload samples.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {
            "mvp": [
              {
                "filename": "mvp-sanitiser.feature",
                "title": "3-Stage Sanitiser (MVP)",
                "content": "Feature: 3-Stage Sanitiser (MVP)\n  The Sanitiser sits between the Worker's MCP proxy and downstream\n  tool servers. It scans tool responses for injection attempts.\n\n  Background:\n    Given the Sanitiser is running as an isolated subprocess\n\n  Scenario: Pass clean tool response\n    Given a tool response contains normal text content\n    When the Sanitiser processes the response\n    Then the verdict is \"pass\"\n    And the response is forwarded to the Worker unchanged\n\n  Scenario: Block response with injection pattern\n    Given a tool response contains \"ignore previous instructions\"\n    When the Sanitiser processes the response\n    Then the verdict is \"block\"\n    And the response is not forwarded to the Worker\n    And the injection event is logged to the State Store\n\n  Scenario: Strip role tags from response\n    Given a tool response contains \"<system>\" tags\n    When the Sanitiser applies structural stripping\n    Then the role tags are removed from the response\n    And the cleaned response is forwarded\n\n  Scenario: Cap response length\n    Given a tool response exceeds the maximum allowed length\n    When the Sanitiser processes the response\n    Then the response is truncated to the maximum length\n    And the truncation is noted in the log\n\n  Scenario: Fail closed on processing error\n    Given the Sanitiser encounters an internal error during processing\n    When processing a tool response\n    Then the response is blocked (not forwarded)\n    And the error is logged\n"
              }
            ]
          }
        },
        {
          "id": "alert-pipeline",
          "name": "Alert Pipeline",
          "type": "component",
          "layer": "security-sandbox",
          "color": "red",
          "icon": "ðŸ“‹",
          "description": "Blocked injections logged to State Store. Meta-Agent can auto-disable compromised tools via injection feedback loop â€” reads sanitiser alerts and learns to avoid them. Dashboard shows real-time security events feed.",
          "tags": "[\"auto-disable\",\"injection feedback loop\",\"real-time\"]",
          "sort_order": 92,
          "versions": {
            "overview": {
              "content": "Blocked injections logged to State Store. Meta-Agent can auto-disable compromised tools via injection feedback loop â€” reads sanitiser alerts and learns to avoid them. Dashboard shows real-time security events.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        }
      ],
      "versions": {
        "overview": {
          "content": "3-stage sanitiser: regex heuristics â†’ structural strip â†’ optional LLM classifier. Fail-closed. Isolated subprocess. Scans inbound + outbound. Worker proxy only. Security model: Meta-Agent has no sanitiser (internal tools only). Worker has full 3-stage sanitiser. Cross-instance isolation: Worker cannot reach Meta-Agent's tools even if fully compromised. Escalation tools are safe: they write structured data to State Store, not free-text to Meta-Agent's prompt. Dashboard is read-only â€” cannot be used as attack vector. Graph writes: Worker cannot write to either graph â€” cannot poison knowledge even if fully compromised. In full-auto mode: sanitiser is the only defence against prompt injection. Write fence still applies for destructive ops. Injection feedback loop lets Meta-Agent auto-disable compromised tools.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      }
    },
    {
      "id": "downstream-tools",
      "name": "Downstream MCP Tool Servers",
      "type": "layer",
      "layer": null,
      "color": "amber",
      "icon": "ðŸ”§",
      "description": "External tool servers â€” search, email, database, filesystem, code execution, custom. Hot-swappable â€” Meta-Agent adds/removes at runtime via proxy_admin.",
      "tags": "[\"external\",\"hot-swappable\",\"runtime managed\"]",
      "sort_order": 100,
      "children": [
        {
          "id": "tool-search",
          "name": "Search",
          "type": "external",
          "layer": "downstream-tools",
          "color": "amber",
          "icon": "ðŸ”",
          "description": "External search MCP server.",
          "tags": "[\"ext\"]",
          "sort_order": 101,
          "versions": {
            "overview": {
              "content": "External search MCP server.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "tool-email",
          "name": "Email",
          "type": "external",
          "layer": "downstream-tools",
          "color": "amber",
          "icon": "âœ‰",
          "description": "External email MCP server.",
          "tags": "[\"ext\"]",
          "sort_order": 102,
          "versions": {
            "overview": {
              "content": "External email MCP server.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "tool-database",
          "name": "Database",
          "type": "external",
          "layer": "downstream-tools",
          "color": "amber",
          "icon": "ðŸ—„",
          "description": "External database MCP server.",
          "tags": "[\"write\"]",
          "sort_order": 103,
          "versions": {
            "overview": {
              "content": "External database MCP server.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "tool-filesystem",
          "name": "Filesystem",
          "type": "external",
          "layer": "downstream-tools",
          "color": "amber",
          "icon": "ðŸ“‚",
          "description": "External filesystem MCP server.",
          "tags": "[\"write\"]",
          "sort_order": 104,
          "versions": {
            "overview": {
              "content": "External filesystem MCP server.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "tool-code-exec",
          "name": "Code Exec",
          "type": "external",
          "layer": "downstream-tools",
          "color": "amber",
          "icon": "ðŸ’»",
          "description": "External code execution MCP server.",
          "tags": "[\"write\"]",
          "sort_order": 105,
          "versions": {
            "overview": {
              "content": "External code execution MCP server.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "tool-custom",
          "name": "Custom",
          "type": "external",
          "layer": "downstream-tools",
          "color": "amber",
          "icon": "ðŸ§©",
          "description": "Custom MCP servers â€” hot-swappable, added/removed by Meta-Agent at runtime.",
          "tags": "[\"dynamic\"]",
          "sort_order": 106,
          "versions": {
            "overview": {
              "content": "Custom MCP servers â€” hot-swappable, added/removed by Meta-Agent at runtime.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        }
      ],
      "versions": {
        "overview": {
          "content": "External MCP tool servers. Search, email, database, filesystem, code execution, custom. Hot-swappable â€” Meta-Agent adds/removes at runtime.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      }
    },
    {
      "id": "bdd-tdd-pipeline",
      "name": "BDD/TDD Phase Pipeline",
      "type": "layer",
      "layer": null,
      "color": "teal",
      "icon": "ðŸ”„",
      "description": "Strict 8-phase pipeline enforced by Meta-Agent, executed by Worker. Each phase is a separate dispatch. Worker sees only the current phase â€” never what comes next. Every phase ends with a git commit creating a clean rollback point. Meta-Agent verifies phase gate before advancing. If gate fails, re-dispatch same phase. Phases â‘¦ and â‘§ are audit-only â€” violations feed back as targeted fix dispatches, then re-audit.",
      "tags": "[\"phase isolation\",\"git commits\",\"gate verification\"]",
      "sort_order": 110,
      "children": [
        {
          "id": "phase-feature",
          "name": "â‘  Feature",
          "type": "phase",
          "layer": "bdd-tdd-pipeline",
          "color": "gold",
          "icon": "ðŸ“",
          "description": "Write the .feature file. Describe the behaviour in Gherkin. DO NOT write any tests or code. Gate: .feature file exists. Git commit after phase.",
          "tags": "[\"gherkin\",\"gate: .feature exists\"]",
          "sort_order": 111,
          "versions": {
            "overview": {
              "content": "Write the .feature file. Describe the behaviour in Gherkin. DO NOT write any tests or code. Gate: .feature file exists. Git commit after phase.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "phase-steps",
          "name": "â‘¡ Step Tests",
          "type": "phase",
          "layer": "bdd-tdd-pipeline",
          "color": "cyan",
          "icon": "ðŸ§ª",
          "description": "Write failing step definitions for this feature file. DO NOT implement any production code. Gate: step files exist. Git commit after phase.",
          "tags": "[\"failing tests\",\"gate: step files exist\"]",
          "sort_order": 112,
          "versions": {
            "overview": {
              "content": "Write failing step definitions for this feature file. DO NOT implement any production code. Gate: step files exist. Git commit after phase.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "phase-units",
          "name": "â‘¢ Unit Tests",
          "type": "phase",
          "layer": "bdd-tdd-pipeline",
          "color": "purple",
          "icon": "ðŸ§ª",
          "description": "Write failing unit tests for the components you'll need. DO NOT implement any production code. Gate: test files exist. Git commit after phase.",
          "tags": "[\"failing tests\",\"gate: test files exist\"]",
          "sort_order": 113,
          "versions": {
            "overview": {
              "content": "Write failing unit tests for the components you'll need. DO NOT implement any production code. Gate: test files exist. Git commit after phase.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "phase-red",
          "name": "â‘£ Red",
          "type": "phase",
          "layer": "bdd-tdd-pipeline",
          "color": "red",
          "icon": "ðŸ”´",
          "description": "Run all tests. Confirm they fail. Report which tests fail and why. DO NOT fix anything. Gate: tests fail. Git commit after phase.",
          "tags": "[\"confirm failure\",\"gate: tests fail\"]",
          "sort_order": 114,
          "versions": {
            "overview": {
              "content": "Run all tests. Confirm they fail. Report which tests fail and why. DO NOT fix anything. Gate: tests fail. Git commit after phase.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "phase-green",
          "name": "â‘¤ Green",
          "type": "phase",
          "layer": "bdd-tdd-pipeline",
          "color": "green",
          "icon": "ðŸŸ¢",
          "description": "Write the minimum production code to make all tests pass. DO NOT refactor or optimise. Gate: tests pass. Git commit after phase.",
          "tags": "[\"minimum code\",\"gate: tests pass\"]",
          "sort_order": 115,
          "versions": {
            "overview": {
              "content": "Write the minimum production code to make all tests pass. DO NOT refactor or optimise. Gate: tests pass. Git commit after phase.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "phase-refactor",
          "name": "â‘¥ Refactor",
          "type": "phase",
          "layer": "bdd-tdd-pipeline",
          "color": "sky",
          "icon": "ðŸ”§",
          "description": "Refactor for clarity, DRY, naming. All tests must still pass. DO NOT add new functionality. Gate: tests still pass. Git commit after phase.",
          "tags": "[\"clarity\",\"dry\",\"gate: tests still pass\"]",
          "sort_order": 116,
          "versions": {
            "overview": {
              "content": "Refactor for clarity, DRY, naming. All tests must still pass. DO NOT add new functionality. Gate: tests still pass. Git commit after phase.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "phase-arch-review",
          "name": "â‘¦ Arch Review",
          "type": "phase",
          "layer": "bdd-tdd-pipeline",
          "color": "orange",
          "icon": "ðŸ›",
          "description": "LLM-driven audit agent (not a linter). Audit against Clean Architecture standards. Report violations: dependency direction (inner layers importing outer), layer boundary leaks (business logic in controllers, HTTP in domain), abstraction leaks (SQL in repository interface), use case isolation. Traverses Code Graph DATA_FLOW and IMPORTS edges to verify dependency direction structurally. DO NOT fix â€” only report. Report format: {violations: [{file, line, rule, severity, explanation}], passed: bool}. If violations found, Meta-Agent dispatches targeted fix phases then re-runs this review. Gate: 0 violations. Git commit after phase.",
          "tags": "[\"audit-only\",\"clean architecture\",\"gate: 0 violations\"]",
          "sort_order": 117,
          "versions": {
            "overview": {
              "content": "LLM-driven audit agent. Audit against Clean Architecture: dependency direction (inner layers importing outer = violation), layer boundaries (business logic in controllers), abstraction leaks (SQL in repository interface), use case isolation. Traverses Code Graph DATA_FLOW and IMPORTS edges structurally. DO NOT fix â€” only report. Report: {violations: [{file, line, rule, severity, explanation}], passed: bool}. Gate: 0 violations. Git commit after phase.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        },
        {
          "id": "phase-sec-review",
          "name": "â‘§ Sec Review",
          "type": "phase",
          "layer": "bdd-tdd-pipeline",
          "color": "rose",
          "icon": "ðŸ”’",
          "description": "LLM-driven security audit agent. Check: injection vectors (SQL, XSS, command injection, path traversal), auth/authz gaps (endpoints without auth middleware, missing permission checks, privilege escalation), secrets exposure (hardcoded keys, tokens in logs, secrets in error messages, .env leaks), unsafe dependencies (known CVEs, deprecated crypto, insecure defaults). Checks compliance requirements from User KG (e.g. \"client requires SOC2\" â†’ enforce specific controls). DO NOT fix â€” only report. Same report format as Arch Review. Gate: 0 findings. Git commit after phase.",
          "tags": "[\"audit-only\",\"security\",\"gate: 0 findings\",\"user kg compliance\"]",
          "sort_order": 118,
          "versions": {
            "overview": {
              "content": "LLM-driven security audit. Injection vectors (SQL, XSS, command injection, path traversal), auth/authz gaps (missing middleware, privilege escalation), secrets exposure (hardcoded keys, tokens in logs, .env leaks), unsafe dependencies (CVEs, deprecated crypto). Checks User KG compliance requirements (e.g. SOC2). DO NOT fix â€” only report. Same report format. Gate: 0 findings. Git commit after phase.",
              "progress": 0,
              "status": "planned",
              "updated_at": "2026-02-10 09:56:50"
            }
          },
          "features": {}
        }
      ],
      "versions": {
        "overview": {
          "content": "Strict 8-phase pipeline enforced by Meta-Agent: Feature â†’ Steps â†’ Units â†’ Red â†’ Green â†’ Refactor â†’ Arch Review â†’ Sec Review. Every phase ends with a git commit. LLM agents are bad at process discipline. Given \"build a login feature\", they'll jump straight to implementation, skip tests, or refactor before proving anything works. Phase isolation prevents this â€” the Worker can't skip ahead because it doesn't know what \"ahead\" is. The forbidden_actions field explicitly blocks forward-leaking behaviour. This turns the Meta-Agent into a process enforcer, not just a task decomposer. Review phases â‘¦ â‘§ are audit-only â€” dispatched as read-only inspections. Worker reports violations but is forbidden from modifying code. Meta-Agent reads the report, dispatches separate fix phases with specific violations as constraints. Prevents the \"fix one thing, break another\" cascade. Phases are extensible: add performance review, accessibility audit, API design review â€” same pattern.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      }
    }
  ],
  "nodes": [
    {
      "id": "observability-dashboard",
      "name": "Observability Dashboard",
      "type": "layer",
      "layer": null,
      "color": "sky",
      "icon": "ðŸ“Š",
      "description": "Runtime Visibility â€” read-only web UI that observes but never mutates. The single pane of glass for both observation and control.",
      "tags": "[\"read-only\",\"web ui\",\"live updates\"]",
      "sort_order": 10,
      "versions": {
        "overview": {
          "content": "Read-only web UI. Process view, goal feed, tool timeline, security events, graph explorers. The dashboard is a thin web UI (React / plain HTML) that reads from two sources: the State Store (goals, tasks, tool logs, escalations, checkpoints) and the Supervisor's health API (process status, heartbeat data, resource usage). It writes nothing â€” pure read-only observer. Optional: SSE/WebSocket push from State Store for live updates without polling. The Human Gate approval actions can be embedded here too, making it the single pane of glass for both observation and control.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "live-dashboard",
      "name": "Live Dashboard",
      "type": "component",
      "layer": "observability-dashboard",
      "color": "sky",
      "icon": "ðŸ“Š",
      "description": "Real-time view of the entire runtime. Read-only â€” it observes but never mutates. Built as a simple web app (React / plain HTML) that polls the State Store + Supervisor health API. Runs as a separate process managed by the Supervisor. Think: the runtime equivalent of the process tree diagram, but live. Reads from two sources: State Store (goals, tasks, tool logs, escalations, checkpoints) and Supervisor health API (process status, heartbeat data, resource usage). It writes nothing â€” pure read-only observer. Optional: SSE/WebSocket push from State Store for live updates without polling. Human Gate approval actions can be embedded here, making it the single pane of glass for both observation and control.",
      "tags": "[\"read-only\",\"web ui\",\"sse/websocket\"]",
      "sort_order": 11,
      "versions": {
        "mvp": {
          "content": "Single-page web app showing process status (up/down) and current goal. Polls Supervisor health API every 5s. Basic goal queue display from State Store. Static HTML + vanilla JS.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "overview": {
          "content": "Real-time view of the entire runtime. Read-only â€” it observes but never mutates. Built as a simple web app (React / plain HTML) that polls the State Store + Supervisor health API. Runs as a separate process managed by the Supervisor. Think: the runtime equivalent of the process tree diagram, but live. Data sources: State Store â†’ goals, tasks, tool call logs, escalations, checkpoints, fast-path records, injection events. Supervisor Health API â†’ process status, uptime, restart count, memory, current model per instance. No direct process inspection â€” dashboard never connects to OpenCode or proxies directly. Push vs Poll: SSE from State Store for live updates; poll Supervisor health every 5s. Human Gate embedded: approval buttons for gated tasks + escalation responses in same UI.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "v1": {
          "content": "Full process tree view with live status. Goal & task feed with click-to-inspect. Tool call timeline with filtering. Security events panel. Escalation queue with response actions.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "v2": {
          "content": "SSE/WebSocket for real-time push updates. Entity Explorer for User KG. Repo Map for Code Graph. Embedded Human Gate approval UI. Performance metrics and resource graphs.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {
        "mvp": [
          {
            "filename": "mvp-dashboard.feature",
            "title": "Live Dashboard (MVP)",
            "content": "Feature: Live Dashboard (MVP)\n  A read-only web UI showing process status and current goal.\n  Polls the Supervisor health API and State Store.\n\n  Background:\n    Given the Dashboard web app is running\n\n  Scenario: Display process status\n    Given the Supervisor health API reports Meta-Agent as \"running\" and Worker as \"running\"\n    When the Dashboard polls the health API\n    Then both processes are shown with \"running\" status indicators\n\n  Scenario: Display current goal\n    Given the State Store contains a goal \"Build user auth\" with status \"in-progress\"\n    When the Dashboard polls the State Store\n    Then the current goal \"Build user auth\" is displayed\n    And its status shows \"in-progress\"\n\n  Scenario: Auto-refresh on interval\n    Given the Dashboard is displaying process status\n    When 5 seconds have elapsed\n    Then the Dashboard polls the health API again\n    And the display updates with fresh data\n\n  Scenario: Show offline state\n    Given the Supervisor health API is unreachable\n    When the Dashboard polls the health API\n    Then a \"Supervisor Unreachable\" indicator is shown\n\n  Scenario: Read-only â€” no mutation endpoints\n    Given the Dashboard is running\n    Then it exposes no POST, PUT, or DELETE endpoints\n    And all data access is via GET requests\n"
          }
        ]
      }
    },
    {
      "id": "live-process-view",
      "name": "Live Process View",
      "type": "component",
      "layer": "observability-dashboard",
      "color": "sky",
      "icon": "ðŸ”´",
      "description": "Process tree with real-time status: running, recovering, crashed, paused for every child. Uptime, restart count, current model, memory usage per instance.",
      "tags": "[\"running\",\"recovering\",\"crashed\",\"paused\"]",
      "sort_order": 12,
      "versions": {
        "overview": {
          "content": "Process tree with real-time status: running, recovering, crashed, paused for every child. Uptime, restart count, current model, memory usage per instance.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "goal-task-feed",
      "name": "Goal & Task Feed",
      "type": "component",
      "layer": "observability-dashboard",
      "color": "sky",
      "icon": "ðŸ“‹",
      "description": "Live stream of the Goal Queue. Current goal, decomposed sub-tasks, completion status. See what the Meta-Agent is planning and what the Worker is executing. Clickable to inspect full task payloads.",
      "tags": "[\"live stream\",\"clickable\",\"task payloads\"]",
      "sort_order": 13,
      "versions": {
        "overview": {
          "content": "Live stream of the Goal Queue. Current goal, decomposed sub-tasks, completion status. See what the Meta-Agent is planning and what the Worker is executing. Clickable to inspect full task payloads.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "tool-call-timeline",
      "name": "Tool Call Timeline",
      "type": "component",
      "layer": "observability-dashboard",
      "color": "sky",
      "icon": "ðŸ”§",
      "description": "Chronological feed of every tool call (both instances). Shows: tool name, args (truncated), response status, latency, sanitiser verdict (pass/block). Filterable by instance, tool, and status. This is your debugging lifeline.",
      "tags": "[\"chronological\",\"filterable\",\"debugging lifeline\"]",
      "sort_order": 14,
      "versions": {
        "overview": {
          "content": "Chronological feed of every tool call (both instances). Shows: tool name, args (truncated), response status, latency, sanitiser verdict (pass/block). Filterable by instance, tool, and status. This is your debugging lifeline.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "security-events",
      "name": "Security Events",
      "type": "component",
      "layer": "observability-dashboard",
      "color": "sky",
      "icon": "ðŸ›¡",
      "description": "Sanitiser verdicts, blocked injections with raw payload preview, injection frequency per tool, auto-disable events. Links to full audit log entries. Alerts when injection rate exceeds threshold.",
      "tags": "[\"audit log\",\"injection frequency\",\"auto-disable\"]",
      "sort_order": 15,
      "versions": {
        "overview": {
          "content": "Sanitiser verdicts, blocked injections with raw payload preview, injection frequency per tool, auto-disable events. Links to full audit log entries. Alerts when injection rate exceeds threshold.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "escalation-queue",
      "name": "Escalation Queue",
      "type": "component",
      "layer": "observability-dashboard",
      "color": "sky",
      "icon": "â¸",
      "description": "Worker escalation requests waiting for Meta-Agent or human review. Shows the Worker's question, context snapshot, and available actions: respond, override, or abort task.",
      "tags": "[\"respond\",\"override\",\"abort\"]",
      "sort_order": 16,
      "versions": {
        "overview": {
          "content": "Worker escalation requests waiting for Meta-Agent or human review. Shows the Worker's question, context snapshot, and available actions: respond, override, or abort task.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "entity-explorer",
      "name": "Entity Explorer",
      "type": "component",
      "layer": "observability-dashboard",
      "color": "sky",
      "icon": "ðŸ‘¤",
      "description": "Browse the User Knowledge Graph. See people, projects, preferences, and their relationships. Understand what the agents \"know about you\".",
      "tags": "[\"new\",\"user kg\",\"browse\"]",
      "sort_order": 17,
      "versions": {
        "overview": {
          "content": "Browse the User Knowledge Graph. See people, projects, preferences, and their relationships. Understand what the agents \"know about you\".",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "repo-map",
      "name": "Repo Map",
      "type": "component",
      "layer": "observability-dashboard",
      "color": "sky",
      "icon": "ðŸ—º",
      "description": "Visualise the Code Graph. Module hierarchy, file deps, data flows. See the agent's structural understanding of your codebase.",
      "tags": "[\"new\",\"code graph\",\"visualise\"]",
      "sort_order": 18,
      "versions": {
        "overview": {
          "content": "Visualise the Code Graph. Module hierarchy, file deps, data flows. See the agent's structural understanding of your codebase.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "human-gate-dashboard",
      "name": "Human Gate (Dashboard)",
      "type": "component",
      "layer": "observability-dashboard",
      "color": "sky",
      "icon": "â›³",
      "description": "Approval queue + escalation responses. Gate actions embeddable in dashboard UI.",
      "tags": "[\"approval\",\"embedded\"]",
      "sort_order": 19,
      "versions": {
        "overview": {
          "content": "Approval queue + escalation responses. Gate actions embeddable in dashboard UI.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "supervisor-layer",
      "name": "Supervisor",
      "type": "layer",
      "layer": null,
      "color": "purple",
      "icon": "ðŸ‘",
      "description": "The Only Immortal Process â€” process management, signal handling, recovery state machine. No LLM, no planning. If it dies, systemd/Docker restarts it.",
      "tags": "[\"immortal\",\"no llm\",\"process manager\"]",
      "sort_order": 20,
      "versions": {
        "overview": {
          "content": "The only immortal process. No LLM. Process manager + crash recovery + heartbeat. Exposes health API on :9100. Kill switch: /stop HTTP endpoint + SIGTERM handler. If it dies, systemd/Docker restarts it. Recovery sequence on crash detection: (1) Kill hung process if still alive. (2) Read last checkpoint from State Store. (3) Rebuild config via DSL. (4) Inject resume context via Context Rebuilder. (5) Respawn fresh OpenCode process (new PID, clean slate, resume prompt). (6) Exponential backoff if repeated failures, max 5 retries â†’ alert Human Gate.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "supervisor",
      "name": "Supervisor",
      "type": "component",
      "layer": "supervisor-layer",
      "color": "purple",
      "icon": "ðŸ‘",
      "description": "Manages all child processes. Heartbeat + crash recovery with tiered priority. No LLM, no planning â€” just process management, signal handling, and the recovery state machine. This is what makes it stable: it has almost no reasons to crash. If it does, systemd/Docker restarts it. Exposes a health API (HTTP on :9100) for the dashboard. Kill switch: /stop HTTP endpoint + SIGTERM handler â†’ instant halt of all children. Emergency brake for runaway agents.",
      "tags": "[\"immortal\",\"health api\",\"kill switch\",\"no llm\"]",
      "sort_order": 21,
      "versions": {
        "mvp": {
          "content": "Spawn and monitor two child processes (meta-agent, worker). Detect crashes via waitpid(). Restart crashed children with basic retry logic. Expose /health HTTP endpoint returning JSON process status. Handle SIGTERM for graceful shutdown of all children.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "overview": {
          "content": "Manages all child processes. Heartbeat + crash recovery with tiered priority. No LLM, no planning â€” just process management, signal handling, and the recovery state machine. This is what makes it stable: it has almost no reasons to crash. If it does, systemd/Docker restarts it. Exposes a health API (HTTP on :9100) for the dashboard. Kill switch: /stop HTTP endpoint + SIGTERM handler â†’ instant halt of all children. Why a Supervisor, not a cron job? (1) Instant detection: waitpid() returns the moment a child exits. Cron's worst-case latency = poll interval. (2) Crash loop handling: Supervisor tracks restart count + applies exponential backoff. (3) Multi-step recovery: kill â†’ checkpoint read â†’ config rebuild â†’ context inject â†’ respawn. (4) Lifecycle ownership: Supervisor owns the full process tree â€” PIDs, health, state. (5) Signal handling: catches SIGTERM/SIGCHLD and coordinates graceful shutdown. Stability hierarchy: Tier âˆž (Supervisor) immortal â†’ Tier 0 (Meta-Agent) recovered first â†’ Tier 1 (Worker) expendable. Recovery order: Supervisor â†’ Meta-Agent â†’ Worker. Each tier can recover the one below it.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "v1": {
          "content": "Add exponential backoff on repeated crashes. Liveness probe (hang detection via output timeout_ms). Recovery state machine with tiered priority (meta-agent first). Checkpoint-aware recovery â€” read last checkpoint before respawn. Human Gate alerting after max 5 retries.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "v2": {
          "content": "Full config-as-code DSL for spawn configuration. Resource monitoring (memory, CPU per child). Kill switch /stop HTTP endpoint. Dashboard SSE push for process events. Per-instance gate policies. Runtime flag switching for gate modes.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {
        "mvp": [
          {
            "filename": "mvp-process-management.feature",
            "title": "Supervisor Process Management (MVP)",
            "content": "Feature: Supervisor Process Management (MVP)\n  The Supervisor spawns and monitors child processes.\n  It detects crashes and restarts children with basic retry logic.\n\n  Background:\n    Given the Supervisor process is running\n\n  Scenario: Spawn child processes on startup\n    When the Supervisor starts\n    Then it spawns the Meta-Agent process\n    And it spawns the Worker process\n    And both processes are in \"running\" state\n\n  Scenario: Detect child crash via waitpid\n    Given the Meta-Agent process is running\n    When the Meta-Agent process exits unexpectedly\n    Then the Supervisor detects the exit within 100ms\n    And the exit is logged with the process ID and exit code\n\n  Scenario: Restart crashed child\n    Given the Worker process has crashed\n    When the Supervisor detects the crash\n    Then it restarts the Worker process\n    And the new process is in \"running\" state\n    And the restart count is incremented\n\n  Scenario: Respect maximum retry limit\n    Given the Worker has crashed 5 times consecutively\n    When the Worker crashes again\n    Then the Supervisor does not restart the Worker\n    And the Worker state is set to \"failed\"\n    And an alert is logged\n\n  Scenario: Health API returns process status\n    Given both child processes are running\n    When a GET request is made to /health\n    Then the response status is 200\n    And the response body contains status for each child process\n    And each status includes \"pid\", \"state\", and \"uptime\"\n\n  Scenario: Graceful shutdown on SIGTERM\n    Given both child processes are running\n    When the Supervisor receives SIGTERM\n    Then it sends SIGTERM to all child processes\n    And it waits for children to exit\n    And it exits with code 0\n"
          }
        ]
      }
    },
    {
      "id": "dual-heartbeat",
      "name": "Dual Heartbeat",
      "type": "component",
      "layer": "supervisor-layer",
      "color": "purple",
      "icon": "ðŸ’“",
      "description": "Monitors both OpenCode instances independently via waitpid() + liveness probes. Instant crash detection (zero latency) â€” waitpid() returns the moment a child exits. Periodic liveness probe for hang detection â€” if no output for timeout_ms, treat as hung. Detects: exit, hang, OOM. If the Worker crashes â†’ recover using Meta-Agent's last plan. If the Meta-Agent crashes â†’ recover it first (higher priority), then it re-dispatches the Worker. Exponential backoff, max 5 retries â†’ alert Human Gate.",
      "tags": "[\"waitpid\",\"zero latency\",\"meta first\",\"worker second\",\"exponential backoff\"]",
      "sort_order": 22,
      "versions": {
        "mvp": {
          "content": "waitpid() loop for crash detection. Basic restart on exit. Retry counter with max limit. Log crash events.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "overview": {
          "content": "Monitors both OpenCode instances independently via waitpid() + liveness probes. Instant crash detection (zero latency) â€” waitpid() returns the moment a child exits. Periodic liveness probe for hang detection â€” if no output for timeout_ms, treat as hung. Detects: exit, hang, OOM. If Worker crashes â†’ recover using Meta-Agent's last plan. If Meta-Agent crashes â†’ recover it first (higher priority), then it re-dispatches Worker. Exponential backoff, max 5 retries â†’ alert Human Gate.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "human-gate",
      "name": "Human Gate",
      "type": "component",
      "layer": "supervisor-layer",
      "color": "pink",
      "icon": "â›³",
      "description": "Three modes: full-auto, approve-goals, approve-all. Plus write fence: dangerous ops require approval even in full-auto. Also surfaces escalation requests from the Worker. Write fence per-instance: Meta-Agent config mutations and Worker destructive ops can have independent gate policies. Gate mode is a runtime flag â€” switch between modes without restarting any process.",
      "tags": "[\"full-auto\",\"approve-goals\",\"approve-all\",\"write fence\",\"runtime flag\"]",
      "sort_order": 23,
      "versions": {
        "mvp": {
          "content": "Basic approval queue. CLI-based approve/reject. Write fence for destructive operations (hardcoded list). Block until approved or timeout.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "overview": {
          "content": "Three modes: full-auto, approve-goals, approve-all. Plus write fence: dangerous ops require approval even in full-auto. Also surfaces escalation requests from the Worker. Write fence per-instance: Meta-Agent config mutations and Worker destructive ops have independent gate policies. Gate mode is a runtime flag â€” switch between modes without restarting.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "v1": {
          "content": "Runtime mode switching (full-auto, approve-goals, approve-all). Per-instance gate policies. Escalation forwarding from Meta-Agent. Dashboard-embeddable approval UI.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "v2": {
          "content": "Configurable write fence per tool category. Approval delegation rules. Audit trail of all gate decisions. Timeout policies with configurable fallback actions.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {
        "mvp": [
          {
            "filename": "mvp-human-gate.feature",
            "title": "Human Gate (MVP)",
            "content": "Feature: Human Gate (MVP)\n  The Human Gate provides an approval queue for dangerous\n  operations and a write fence for destructive actions.\n\n  Background:\n    Given the Human Gate is running\n\n  Scenario: Block destructive operation for approval\n    Given the write fence includes \"database drop\" operations\n    When a task requests a database drop\n    Then the task is paused with status \"awaiting_approval\"\n    And the approval request is added to the queue\n\n  Scenario: Approve pending request\n    Given a task is paused awaiting approval\n    When a human approves the request\n    Then the task status changes to \"approved\"\n    And execution resumes\n\n  Scenario: Reject pending request\n    Given a task is paused awaiting approval\n    When a human rejects the request\n    Then the task status changes to \"rejected\"\n    And the task is aborted\n\n  Scenario: Timeout on unanswered request\n    Given a task has been awaiting approval for longer than the timeout\n    When the timeout expires\n    Then the task is aborted\n    And the timeout event is logged\n"
          }
        ]
      }
    },
    {
      "id": "fast-path-router",
      "name": "Fast Path Router",
      "type": "component",
      "layer": "supervisor-layer",
      "color": "lime",
      "icon": "âš¡",
      "description": "Rule engine (no LLM). Classifies tasks as fast, full, or gated. Scores incoming tasks by complexity signals: single-step? (e.g. \"format this file\"), no ambiguity? (clear input/output), no tool mutation needed? (current tools suffice). If all signals pass â†’ direct to Worker, skipping Meta-Agent. Meta-Agent notified after completion via State Store. Cuts latency and cost for simple tasks by ~50%. Configurable: fast_path: \"aggressive\" | \"conservative\" | \"off\". Can query User KG for context (\"does user prefer X for this type of task?\"). If fast-path task fails, re-routed through Meta-Agent.",
      "tags": "[\"fast\",\"full\",\"gated\",\"rule engine\",\"~50% savings\",\"new\"]",
      "sort_order": 24,
      "versions": {
        "mvp": {
          "content": "Simple rule engine: match task text against patterns (single verb, no conditionals, target file exists). Three outputs: fast, full, gated. Configurable threshold.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "overview": {
          "content": "Rule engine (no LLM). Classifies tasks as fast, full, or gated. Scores by complexity signals: single-step, no ambiguity, no tool mutation needed. Configurable: fast_path: \"aggressive\" | \"conservative\" | \"off\". Can query User KG for context. Cuts latency and cost ~50% for simple tasks. Fallback: failed fast-path tasks re-route through Meta-Agent.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "task-router-layer",
      "name": "Task Router",
      "type": "layer",
      "layer": null,
      "color": "lime",
      "icon": "âš¡",
      "description": "Fast Path Decision Point â€” lightweight rule engine (no LLM) routes tasks by complexity: trivial goes direct to Worker, complex goes to Meta-Agent, dangerous requires human approval.",
      "tags": "[\"rule engine\",\"no llm\",\"classifier\"]",
      "sort_order": 30,
      "versions": {
        "overview": {
          "content": "Fast path decision point. Rule engine (no LLM) routes tasks by complexity. Classifier is NOT an LLM â€” it's a rule engine (regex + heuristics on task text). Signals: single verb (\"format\", \"lint\", \"rename\"), no conditional language, target file exists, current tools suffice. Configurable threshold: fast_path: \"aggressive\" | \"conservative\" | \"off\". Meta-Agent stays aware: fast-path completions logged to State Store. Fallback: if fast-path task fails, re-routed through Meta-Agent.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "fast-path",
      "name": "Fast Path",
      "type": "component",
      "layer": "task-router-layer",
      "color": "lime",
      "icon": "âš¡",
      "description": "Rule engine says: single-step, unambiguous, existing tools suffice. Task goes directly to Worker. Meta-Agent notified post-completion via State Store. Flow: task â†’ classifier â†’ FAST â†’ Worker â†’ done â†’ State Store â†’ Meta-Agent reads.",
      "tags": "[\"trivial\",\"direct\",\"skip planner\"]",
      "sort_order": 31,
      "versions": {
        "overview": {
          "content": "Rule engine says: single-step, unambiguous, existing tools suffice. Task goes directly to Worker. Meta-Agent notified post-completion via State Store. Flow: task â†’ classifier â†’ FAST â†’ Worker â†’ done â†’ State Store â†’ Meta-Agent reads.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "full-path",
      "name": "Full Path",
      "type": "component",
      "layer": "task-router-layer",
      "color": "orange",
      "icon": "ðŸ§ ",
      "description": "Classifier says: multi-step, ambiguous, or needs tool changes. Task goes to Meta-Agent for decomposition. Normal planning loop. Flow: task â†’ classifier â†’ FULL â†’ Meta-Agent â†’ plan â†’ dispatch â†’ Worker â†’ State Store.",
      "tags": "[\"complex\",\"decomposition\",\"planning loop\"]",
      "sort_order": 32,
      "versions": {
        "overview": {
          "content": "Classifier says: multi-step, ambiguous, or needs tool changes. Task goes to Meta-Agent for decomposition. Normal planning loop. Flow: task â†’ classifier â†’ FULL â†’ Meta-Agent â†’ plan â†’ dispatch â†’ Worker â†’ State Store.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "gated-path",
      "name": "Gated Path",
      "type": "component",
      "layer": "task-router-layer",
      "color": "purple",
      "icon": "â›³",
      "description": "Classifier or Human Gate flags: destructive, high-cost, or security-sensitive. Task pauses for human approval before any routing. Flow: task â†’ classifier â†’ GATE â†’ Human Gate â†’ approve â†’ (fast or full path).",
      "tags": "[\"dangerous\",\"approval required\",\"security-sensitive\"]",
      "sort_order": 33,
      "versions": {
        "overview": {
          "content": "Classifier or Human Gate flags: destructive, high-cost, or security-sensitive. Task pauses for human approval. Flow: task â†’ classifier â†’ GATE â†’ Human Gate â†’ approve â†’ (fast or full path).",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "knowledge-graphs",
      "name": "Knowledge Graphs",
      "type": "layer",
      "layer": null,
      "color": "gold",
      "icon": "ðŸ§ ",
      "description": "Dual graph stores: User Knowledge Graph (domain context â€” people, projects, preferences) + RPG Code Graph (repo structure â€” files, modules, deps, data flows).",
      "tags": "[\"dual stores\",\"domain context\",\"repo structure\"]",
      "sort_order": 40,
      "versions": {
        "overview": {
          "content": "Dual graph stores. User Knowledge Graph holds domain context (people, projects, preferences). RPG Code Graph holds repo structure (files, modules, deps, data flows). Three stores, three purposes: State Store (operational â€” what's happening now, prunable), User KG (domain â€” who you are, long-lived), Code Graph (repo structure â€” what the codebase looks like, disposable and re-derivable from code).",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "user-knowledge-graph",
      "name": "User Knowledge Graph",
      "type": "store",
      "layer": "knowledge-graphs",
      "color": "gold",
      "icon": "ðŸ‘¤",
      "description": "A persistent graph of the user's world. Nodes are domain entities â€” people, projects, clients, teams, products, preferences, business rules, conventions, deadlines. Edges are typed relationships with metadata. This is not about code â€” it's about understanding who you are and what you care about so agents make contextually appropriate decisions. Entity types: person, project, org, team, preference, convention, deadline, stack, compliance, product, domain-concept, decision. Relationship types: OWNS, PREFERS, WORKS_WITH, HAS_CLIENT, USES_STACK, REQUIRES, CONVENTION, HAS_DEADLINE, DECIDED, DISLIKES. Populated by: (1) User directly â€” onboarding flow or dashboard edits. (2) Meta-Agent â€” infers entities from conversations and patterns over time. (3) Never by Worker â€” same injection-safety principle. Worker reads, never writes. Confidence layering: user-explicit (1.0) > meta-agent-inferred (0.8) > auto-extracted (0.6).",
      "tags": "[\"new\",\"persistent\",\"entity types\",\"relationship types\",\"confidence layering\"]",
      "sort_order": 41,
      "versions": {
        "mvp": {
          "content": "SQLite-backed entity store. Add/query entities with typed relationships. Basic traversal (1-hop neighbours). Manual entity creation via CLI or dashboard. Simple text search across entities.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "overview": {
          "content": "A persistent graph of the user's world. Nodes are domain entities â€” people, projects, clients, teams, products, preferences, business rules, conventions, deadlines. Edges are typed relationships with metadata. This is not about code â€” it's about understanding who you are and what you care about so agents make contextually appropriate decisions. Entity types: person, project, org, team, preference, convention, deadline, stack, compliance, product, domain-concept, decision. Relationship types: OWNS, PREFERS, WORKS_WITH, HAS_CLIENT, USES_STACK, REQUIRES, CONVENTION, HAS_DEADLINE, DECIDED, DISLIKES. Populated by: (1) User directly â€” onboarding flow or dashboard edits. (2) Meta-Agent â€” infers entities from conversations and patterns. (3) Never by Worker â€” injection safety. Confidence layering: user-explicit (1.0) > meta-agent-inferred (0.8) > auto-extracted (0.6). What it solves: Personalisation (\"Alice prefers typed SQL over ORMs\"), project awareness (\"acme-saas uses Next.js + Postgres, client needs SOC2\"), team context (\"Bob is backend lead, prefers PRs\"), decision memory (\"We decided JWT over sessions on Jan 15\"), convention enforcement (\"No ORMs, minimal comments, Tailwind\"), deadline awareness (Meta-Agent prioritises based on known deadlines).",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "v1": {
          "content": "Meta-Agent write access for inferred entities. Confidence layering (user-explicit 1.0 > meta-inferred 0.8). Multi-hop traversal queries. Convention enforcement lookups. Deadline awareness queries.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "v2": {
          "content": "Full graph query language. Temporal awareness (when was this preference set?). Conflict resolution for contradictory preferences. Export/import for portability. Dashboard entity editor.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {
        "mvp": [
          {
            "filename": "mvp-user-kg.feature",
            "title": "User Knowledge Graph (MVP)",
            "content": "Feature: User Knowledge Graph (MVP)\n  A persistent entity-relationship store for domain context:\n  people, projects, preferences, conventions, deadlines.\n\n  Background:\n    Given the User Knowledge Graph SQLite database exists\n\n  Scenario: Add an entity\n    When an entity is added with type \"person\" and name \"Alice\"\n    Then the entity exists in the graph with a unique ID\n    And it has type \"person\" and name \"Alice\"\n\n  Scenario: Add a relationship between entities\n    Given entities \"Alice\" (person) and \"acme-saas\" (project) exist\n    When a relationship \"OWNS\" is added from \"Alice\" to \"acme-saas\"\n    Then the edge exists with type \"OWNS\"\n    And it references both entities\n\n  Scenario: Query 1-hop neighbours\n    Given \"Alice\" has relationships to \"acme-saas\", \"Bob\", and \"minimal-comments\"\n    When querying neighbours of \"Alice\"\n    Then all 3 connected entities are returned\n    And each result includes the relationship type\n\n  Scenario: Search entities by text\n    Given entities \"Alice\", \"Bob\", and \"acme-saas\" exist\n    When searching for \"alice\"\n    Then the entity \"Alice\" is returned\n\n  Scenario: Add entity with metadata\n    When an entity is added with type \"preference\" name \"no-orms\" and metadata '{\"reason\": \"team decision\"}'\n    Then the entity exists with the metadata attached\n"
          }
        ]
      }
    },
    {
      "id": "rpg-code-graph",
      "name": "RPG Code Graph",
      "type": "store",
      "layer": "knowledge-graphs",
      "color": "emerald",
      "icon": "ðŸ—º",
      "description": "An RPG-style structural graph of the current codebase. Encodes file hierarchy, module boundaries, inter-module data flows, function signatures, class inheritance, and import dependencies. Inspired by Microsoft RPG/ZeroRepo (https://arxiv.org/abs/2509.16198). This is a code quality feature â€” it helps the Worker write structurally coherent code by understanding what exists, what depends on what, and where new code should go. Node types: module, file, function, class, interface, package, route, schema, test. Edge types: CONTAINS, IMPORTS, EXPORTS, DATA_FLOW, EXTENDS, IMPLEMENTS, DEPENDS_ON, TESTS, CALLS. Populated by: (1) Static analysis on init â€” AST parse via tree-sitter on repo load (~seconds for repos under 100K LoC). (2) Worker's Checkpointer â€” auto-updates after file edits (re-parse only changed files, diff old vs new, update edges incrementally). (3) Meta-Agent â€” can annotate with higher-level module boundaries and data flow intentions. Lightweight â€” no LLM needed for extraction. Query patterns: topo_order(module), data_flow(A,B), dependents(file), pattern(type,dir), where_to_add(capability).",
      "tags": "[\"new\",\"tree-sitter\",\"ast parsing\",\"disposable\",\"re-derivable\",\"query patterns\"]",
      "sort_order": 42,
      "versions": {
        "mvp": {
          "content": "Static analysis on repo load using tree-sitter. Build initial graph from imports, exports, class hierarchy. Basic queries: list files in module, show imports for file. SQLite-backed.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "overview": {
          "content": "An RPG-style structural graph of the current codebase. Encodes file hierarchy, module boundaries, inter-module data flows, function signatures, class inheritance, and import dependencies. Inspired by Microsoft RPG/ZeroRepo (arxiv.org/abs/2509.16198). This is a code quality feature â€” it helps the Worker write structurally coherent code. Node types: module, file, function, class, interface, package, route, schema, test. Edge types: CONTAINS, IMPORTS, EXPORTS, DATA_FLOW, EXTENDS, IMPLEMENTS, DEPENDS_ON, TESTS, CALLS. What it solves: Dependency awareness (Worker knows what imports what before editing), placement decisions (\"where should rate limiting go?\" â†’ traverse moduleâ†’fileâ†’function), topological code generation (build in dependency order), data flow understanding (inter-module edges), pattern consistency (existing patterns visible), blast radius estimation (Meta-Agent traverses deps). Implementation: (1) Initial build on repo load â€” tree-sitter AST parse, extract files/imports/exports/classes/functions, infer modules from directory structure, ~seconds for repos under 100K LoC. (2) Incremental update on edit â€” Checkpointer detects file-edit tool calls, re-parses only changed files, diffs old vs new, updates edges incrementally. (3) Query patterns â€” topo_order(module), data_flow(A,B), dependents(file), pattern(type,dir), where_to_add(capability).",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "v1": {
          "content": "Incremental updates via Checkpointer (re-parse only changed files). Dependency traversal (topo_order, dependents). Data flow edges between modules. Pattern queries.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "v2": {
          "content": "Full where_to_add capability suggestions. Blast radius estimation. Meta-Agent annotations. Multi-language AST support. Dashboard Repo Map visualization.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {
        "mvp": [
          {
            "filename": "mvp-code-graph.feature",
            "title": "RPG Code Graph (MVP)",
            "content": "Feature: RPG Code Graph (MVP)\n  Static analysis on repo load builds a structural graph of the\n  codebase: files, imports, exports, classes, functions.\n\n  Background:\n    Given a repository with source files exists\n\n  Scenario: Build initial graph from repo\n    When the Code Graph builder runs on the repository\n    Then nodes are created for each source file\n    And edges are created for import relationships\n    And the graph is stored in SQLite\n\n  Scenario: Extract function exports\n    Given a file \"auth/handler.ts\" exports function \"verifyToken\"\n    When the AST parser processes the file\n    Then a function node \"verifyToken\" exists\n    And an EXPORTS edge connects the file to the function\n\n  Scenario: Extract import relationships\n    Given \"api/routes.ts\" imports from \"auth/handler.ts\"\n    When the AST parser processes both files\n    Then an IMPORTS edge connects \"api/routes.ts\" to \"auth/handler.ts\"\n\n  Scenario: Infer modules from directory structure\n    Given the repository has directories \"auth/\", \"api/\", \"db/\"\n    When the Code Graph builder runs\n    Then module nodes are created for \"auth\", \"api\", \"db\"\n    And CONTAINS edges connect modules to their files\n\n  Scenario: Query files in a module\n    Given the module \"auth\" contains \"handler.ts\" and \"middleware.ts\"\n    When querying files in module \"auth\"\n    Then both files are returned\n"
          }
        ]
      }
    },
    {
      "id": "dual-agents",
      "name": "Dual OpenCode Instances",
      "type": "layer",
      "layer": null,
      "color": "orange",
      "icon": "ðŸ§ ",
      "description": "Two stock OpenCode instances. Meta-Agent (Planner) uses cheap/fast model (Haiku/Sonnet), plans and dispatches. Worker (Executor) uses strong model (Sonnet/Opus), executes one phase at a time. They share no tools â€” isolation by design.",
      "tags": "[\"stock opencode\",\"dual instances\",\"tool isolation\"]",
      "sort_order": 50,
      "versions": {
        "overview": {
          "content": "Two stock OpenCode instances. Meta-Agent (Planner) uses cheap model (Haiku/Sonnet), plans and dispatches. Worker (Executor) uses strong model (Sonnet/Opus), executes one phase at a time. Why two instances? (1) Separation of concerns: planning and execution have different tool sets, models, cost profiles, and risk levels. (2) Blast radius: a prompt injection in the Worker can't reach the Planner â€” they share no tools or MCP connection. (3) Independent recovery: Worker can crash and be re-dispatched without losing Meta-Agent's plan state. (4) Cost optimisation: Planner uses cheap model, Worker uses capable model. (5) Dogfooding: you build one runtime, not two systems. Both instances use the same config DSL, proxy, and checkpoint infra.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "meta-agent",
      "name": "Meta-Agent (Planner)",
      "type": "component",
      "layer": "dual-agents",
      "color": "orange",
      "icon": "ðŸ§ ",
      "description": "Stock OpenCode, planning system prompt, cheap/fast model (Haiku/Sonnet). This instance never touches the codebase or external APIs directly. It only plans, evaluates, and dispatches. Tier-0: recovered first. If this is down, the Worker has no direction. Only internal tools, no injection surface. Traverses User KG to align plans with user preferences, deadlines, team context. Reads Code Graph to understand repo structure before decomposing coding tasks. Also handles escalation responses: reads Worker's request_clarification entries from State Store, reasons about them, and writes guidance back â€” which the Worker receives on its next checkpoint resume or via check_escalation_response tool. System prompt: \"You are a task planner. Use your tools to: read the goal queue, check worker status, decompose goals into tasks, dispatch tasks, evaluate results, and generate follow-up goals. You may also evolve the worker's tools and config when needed.\" The loop emerges from the prompt + tool availability.",
      "tags": "[\"tier-0\",\"10 internal tools\",\"reads/writes user kg\",\"reads code graph\",\"haiku/sonnet\",\"new\"]",
      "sort_order": 51,
      "versions": {
        "mvp": {
          "content": "Single OpenCode instance with planning system prompt. Read goal queue, decompose into sub-tasks, dispatch to Worker via State Store. Read Worker progress from checkpoints. Basic goal â†’ task decomposition.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "overview": {
          "content": "Stock OpenCode, planning system prompt, cheap/fast model (Haiku/Sonnet). This instance never touches the codebase or external APIs directly. It only plans, evaluates, and dispatches. Tier-0: recovered first. If this is down, the Worker has no direction. Only internal tools, no injection surface. Traverses User KG to align plans with user preferences, deadlines, team context. Reads Code Graph to understand repo structure before decomposing coding tasks. Also handles escalation responses: reads Worker's request_clarification entries from State Store, reasons about them, and writes guidance back. System prompt: \"You are a task planner. Use your tools to: read the goal queue, check worker status, decompose goals into tasks, dispatch tasks, evaluate results, and generate follow-up goals. You may also evolve the worker's tools and config when needed.\" The loop emerges from the prompt + tool availability. How Meta-Agent uses both graphs: Before planning â€” \"What stack? Deadlines? Preferences?\" Before decomposing â€” \"Which modules? Dependency order? Blast radius?\" Task dispatch enrichment â€” includes relevant KG + Code Graph context in Worker's task prompt. Tool selection â€” User KG says \"prefers Brave over Google\" â†’ configures proxy. Knowledge curation â€” writes inferred preferences to User KG. Self-evolution: tool discovery via tool_registry.search, config mutation via typed builder DSL (not raw JSON), sub-goal generation, prompt evolution based on observed results. Guardrails: budget limits, scope limits, allowed tool categories, model whitelist.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "v1": {
          "content": "Phase-locked BDD/TDD dispatch pipeline. Gate verification between phases. Escalation response handling. User KG reads for planning context. Code Graph reads for repo-aware decomposition.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "v2": {
          "content": "Self-evolution: tool discovery + hot-swap via proxy_admin. Config mutation via DSL. Prompt evolution based on observed results. Knowledge curation â€” write inferred preferences to User KG. Budget and scope guardrails.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {
        "mvp": [
          {
            "filename": "mvp-planning-loop.feature",
            "title": "Meta-Agent Planning Loop (MVP)",
            "content": "Feature: Meta-Agent Planning Loop (MVP)\n  The Meta-Agent reads goals, decomposes them into tasks,\n  and dispatches work to the Worker via the State Store.\n\n  Background:\n    Given the Meta-Agent is running with a planning system prompt\n    And the State Store is accessible\n\n  Scenario: Read next goal from queue\n    Given the goal queue contains \"Build user authentication\"\n    When the Meta-Agent checks the goal queue\n    Then it receives the goal \"Build user authentication\"\n    And the goal status is set to \"in-progress\"\n\n  Scenario: Decompose goal into tasks\n    Given the Meta-Agent has received the goal \"Build user authentication\"\n    When it decomposes the goal\n    Then the State Store contains at least 2 sub-tasks\n    And each sub-task has a description and ordering\n\n  Scenario: Dispatch task to Worker\n    Given a sub-task \"Create login endpoint\" exists in the State Store\n    When the Meta-Agent dispatches the task\n    Then the task status is set to \"dispatched\"\n    And the task includes a description and success criteria\n\n  Scenario: Read Worker progress\n    Given a task has been dispatched to the Worker\n    When the Meta-Agent checks Worker progress\n    Then it receives the latest checkpoint for that task\n    And the checkpoint includes tool calls made and their results\n\n  Scenario: Complete goal when all tasks done\n    Given all sub-tasks for a goal are in \"complete\" status\n    When the Meta-Agent evaluates the goal\n    Then the goal status is set to \"complete\"\n    And the Meta-Agent reads the next goal from the queue\n"
          }
        ]
      }
    },
    {
      "id": "worker",
      "name": "Worker (Executor)",
      "type": "component",
      "layer": "dual-agents",
      "color": "cyan",
      "icon": "âš¡",
      "description": "Stock OpenCode, execution system prompt, strong model (Sonnet/Opus). Tier-1, ephemeral, no fork. Lower stability priority â€” if it crashes, the Meta-Agent re-dispatches. Treated as ephemeral and replaceable. On recovery, the agent continues without knowing it crashed â€” the Context Rebuilder injects a resume prompt that makes it look like a natural continuation. External tools, sanitiser required. Reads User KG to respect user preferences during execution (naming conventions, tech choices). Traverses Code Graph to write structurally coherent code (dependency-aware edits, correct placement). Has two escalation tools: request_clarification to pause and ask the planner for guidance, and check_escalation_response to poll for an answer. System prompt: \"If you're uncertain about scope, direction, or trade-offs, use request_clarification. Don't guess â€” ask.\" Receives tasks as structured system prompt injections: phase, task, constraints, forbidden_actions, available_tools, success_criteria. Single-phase isolation: the Worker sees \"Write failing step tests for this feature file. DO NOT implement any production code.\" It literally cannot skip ahead because it doesn't know what \"ahead\" is. The forbidden_actions field explicitly lists what it must not do (e.g. [\"create production files\", \"modify existing src/\", \"run tests in watch mode\"]).",
      "tags": "[\"tier-1\",\"dynamic tools\",\"reads user kg\",\"reads code graph\",\"sanitiser required\",\"ephemeral\",\"no fork\",\"sonnet/opus\",\"new\"]",
      "sort_order": 52,
      "versions": {
        "mvp": {
          "content": "Single OpenCode instance with execution system prompt. Receive task from State Store, execute with available tools, report results. Basic tool access via MCP proxy.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "overview": {
          "content": "Stock OpenCode, execution system prompt, strong model (Sonnet/Opus). Tier-1, ephemeral, no fork. Lower stability priority â€” if it crashes, the Meta-Agent re-dispatches. Treated as ephemeral and replaceable. On recovery, the agent continues without knowing it crashed â€” the Context Rebuilder injects a resume prompt that makes it look like a natural continuation. External tools, sanitiser required. Reads User KG to respect user preferences during execution. Traverses Code Graph for structurally coherent code. Has escalation tools: request_clarification and check_escalation_response. System prompt: \"If you're uncertain about scope, direction, or trade-offs, use request_clarification. Don't guess â€” ask.\" Receives tasks as structured injections: phase, task, constraints, forbidden_actions, available_tools, success_criteria. Single-phase isolation: Worker sees only current phase, never what comes next. Example forbidden_actions: [\"create production files\", \"modify existing src/\", \"run tests in watch mode\"]. The Worker literally cannot skip ahead because it doesn't know what \"ahead\" is.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "v1": {
          "content": "Phase-locked execution (single phase per dispatch, forbidden_actions enforcement). Escalation tools (request_clarification, check_escalation_response). User KG reads for preference-aware execution. Code Graph reads for structural coherence.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "v2": {
          "content": "Context-aware resume after crash (transparent to agent). Dynamic tool manifest â€” handles hot-swap mid-session. Confidence scoring on outputs. Full sanitiser integration on all external I/O.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {
        "mvp": [
          {
            "filename": "mvp-task-execution.feature",
            "title": "Worker Task Execution (MVP)",
            "content": "Feature: Worker Task Execution (MVP)\n  The Worker receives tasks from the State Store and executes\n  them using available tools via the MCP proxy.\n\n  Background:\n    Given the Worker is running with an execution system prompt\n    And the MCP proxy is accessible with at least one tool\n\n  Scenario: Receive dispatched task\n    Given a task \"Create login endpoint\" is in \"dispatched\" status\n    When the Worker checks for pending tasks\n    Then it receives the task with description and constraints\n\n  Scenario: Execute task with tools\n    Given the Worker has received a task\n    When it executes the task\n    Then it makes at least one tool call via the MCP proxy\n    And each tool call is logged to the State Store\n\n  Scenario: Report task completion\n    Given the Worker has finished executing a task\n    When it reports results\n    Then the task status is set to \"complete\"\n    And the result summary is written to the State Store\n\n  Scenario: Handle tool call failure\n    Given the Worker is executing a task\n    When a tool call returns an error\n    Then the Worker logs the error\n    And it attempts an alternative approach or reports failure\n\n  Scenario: Operate within provided constraints\n    Given the Worker receives a task with forbidden_actions [\"delete files\"]\n    When it executes the task\n    Then it does not call any tool that would delete files\n"
          }
        ]
      }
    },
    {
      "id": "goal-queue",
      "name": "goal_queue",
      "type": "component",
      "layer": "dual-agents",
      "color": "orange",
      "icon": "ðŸ“‹",
      "description": "push, pop, peek, reprioritise â€” manages the persistent goal queue.",
      "tags": "[\"meta-agent tool\"]",
      "sort_order": 53,
      "versions": {
        "overview": {
          "content": "push, pop, peek, reprioritise â€” manages the persistent goal queue.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "state-reader",
      "name": "state_reader",
      "type": "component",
      "layer": "dual-agents",
      "color": "orange",
      "icon": "ðŸ“–",
      "description": "get_checkpoint, get_task_log, get_escalations â€” reads Worker's progress.",
      "tags": "[\"meta-agent tool\"]",
      "sort_order": 54,
      "versions": {
        "overview": {
          "content": "get_checkpoint, get_task_log, get_escalations â€” reads Worker's progress.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "worker-control",
      "name": "worker_control",
      "type": "component",
      "layer": "dual-agents",
      "color": "orange",
      "icon": "ðŸ”§",
      "description": "dispatch, abort, respond_escalation â€” sends phase-locked work to Worker. Dispatch includes phase, forbidden_actions, success_criteria.",
      "tags": "[\"meta-agent tool\",\"phase-locked\"]",
      "sort_order": 55,
      "versions": {
        "overview": {
          "content": "dispatch, abort, respond_escalation â€” sends phase-locked work to Worker. Dispatch includes phase, forbidden_actions, success_criteria.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "proxy-admin",
      "name": "proxy_admin",
      "type": "component",
      "layer": "dual-agents",
      "color": "orange",
      "icon": "ðŸ“¡",
      "description": "register, deregister, list â€” mutates Worker's tool manifest at runtime.",
      "tags": "[\"meta-agent tool\",\"hot-swap\"]",
      "sort_order": 56,
      "versions": {
        "overview": {
          "content": "register, deregister, list â€” mutates Worker's tool manifest at runtime.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "config-mutator",
      "name": "config_mutator",
      "type": "component",
      "layer": "dual-agents",
      "color": "orange",
      "icon": "âš™",
      "description": "update_prompt, update_model, update_agents â€” evolves Worker's config via typed builder DSL. Validated, versioned, rollback-safe. Not raw JSON editing.",
      "tags": "[\"meta-agent tool\",\"dsl\",\"rollback-safe\"]",
      "sort_order": 57,
      "versions": {
        "overview": {
          "content": "update_prompt, update_model, update_agents â€” evolves Worker's config via typed builder DSL. Validated, versioned, rollback-safe.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "tool-registry",
      "name": "tool_registry",
      "type": "component",
      "layer": "dual-agents",
      "color": "orange",
      "icon": "ðŸ”",
      "description": "search, inspect, install â€” discovers new MCP servers from a catalogue.",
      "tags": "[\"meta-agent tool\",\"discovery\"]",
      "sort_order": 58,
      "versions": {
        "overview": {
          "content": "search, inspect, install â€” discovers new MCP servers from a catalogue.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "user-kg-read-meta",
      "name": "user_kg_read (Meta)",
      "type": "component",
      "layer": "dual-agents",
      "color": "gold",
      "icon": "ðŸ‘¤",
      "description": "query, traverse, search â€” Meta-Agent reads User KG for planning context.",
      "tags": "[\"meta-agent tool\",\"new\"]",
      "sort_order": 59,
      "versions": {
        "overview": {
          "content": "query, traverse, search â€” Meta-Agent reads User KG for planning context.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "escalation-flow",
      "name": "Escalation Flow",
      "type": "layer",
      "layer": null,
      "color": "teal",
      "icon": "ðŸ™‹",
      "description": "Worker â†” Meta-Agent communication via shared state. Worker hits ambiguity â†’ calls request_clarification({question, context, options}) â†’ State Store records escalation â†’ Worker pauses â†’ Meta-Agent picks it up on next cycle â†’ reasons â†’ responds via worker_control.respond_escalation â†’ State Store updates â†’ Worker calls check_escalation_response â†’ receives guidance â†’ resumes. Timeout handling: if Meta-Agent does not respond within escalation_timeout_ms, Worker can (a) proceed with best guess, (b) abort, or (c) escalate to Human Gate. Policy set in Worker system prompt.",
      "tags": "[\"async\",\"no blocking rpc\",\"structured payload\"]",
      "sort_order": 60,
      "versions": {
        "overview": {
          "content": "Worker â†” Meta-Agent communication via shared state. Escalation sequence: Worker hits ambiguity â†’ calls request_clarification({question, context, options}) â†’ State Store records with status pending â†’ Worker pauses (returns control to idle loop) â†’ Meta-Agent's state_reader.get_escalations() picks it up â†’ Meta-Agent reasons â†’ calls worker_control.respond_escalation({task_id, guidance}) â†’ State Store updates to resolved â†’ Worker calls check_escalation_response() â†’ receives guidance â†’ resumes. Timeout: if no response within escalation_timeout_ms, Worker can: (a) proceed_best_guess, (b) abort, or (c) escalate_to_human. Design: Worker stays isolated (writes to State Store, not to Meta-Agent directly). Async by design (no blocking RPC). Structured payload: {question, context_snapshot, suggested_options[], urgency}. Crash safety: Checkpointer snapshots escalation state.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "user-kg-write-meta",
      "name": "user_kg_write (Meta)",
      "type": "component",
      "layer": "dual-agents",
      "color": "gold",
      "icon": "âœ",
      "description": "add_entity, add_edge, annotate â€” Meta-Agent writes inferred entities to User KG.",
      "tags": "[\"meta-agent tool\",\"new\"]",
      "sort_order": 60,
      "versions": {
        "overview": {
          "content": "add_entity, add_edge, annotate â€” Meta-Agent writes inferred entities to User KG.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "code-graph-read-meta",
      "name": "code_graph_read (Meta)",
      "type": "component",
      "layer": "dual-agents",
      "color": "emerald",
      "icon": "ðŸ—º",
      "description": "expand, path, topo_order â€” Meta-Agent reads Code Graph for repo-aware decomposition.",
      "tags": "[\"meta-agent tool\",\"new\"]",
      "sort_order": 61,
      "versions": {
        "overview": {
          "content": "expand, path, topo_order â€” Meta-Agent reads Code Graph for repo-aware decomposition.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "code-graph-write-meta",
      "name": "code_graph_write (Meta)",
      "type": "component",
      "layer": "dual-agents",
      "color": "emerald",
      "icon": "âœ",
      "description": "annotate_module, set_data_flow â€” Meta-Agent annotates Code Graph with module boundaries and data flow intentions.",
      "tags": "[\"meta-agent tool\",\"new\"]",
      "sort_order": 62,
      "versions": {
        "overview": {
          "content": "annotate_module, set_data_flow â€” Meta-Agent annotates Code Graph with module boundaries and data flow intentions.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "request-clarification",
      "name": "request_clarification",
      "type": "component",
      "layer": "dual-agents",
      "color": "teal",
      "icon": "ðŸ™‹",
      "description": "Writes question + context snapshot to State Store. Sets task status to paused:awaiting_guidance. Worker halts current execution and waits.",
      "tags": "[\"worker tool\",\"escalation\"]",
      "sort_order": 63,
      "versions": {
        "overview": {
          "content": "Writes question + context snapshot to State Store. Sets task status to paused:awaiting_guidance. Worker halts current execution and waits.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "check-escalation-response",
      "name": "check_escalation_response",
      "type": "component",
      "layer": "dual-agents",
      "color": "teal",
      "icon": "ðŸ“¨",
      "description": "Polls State Store for Meta-Agent's response. Returns guidance or still_pending. Worker resumes when guidance arrives.",
      "tags": "[\"worker tool\",\"escalation\"]",
      "sort_order": 64,
      "versions": {
        "overview": {
          "content": "Polls State Store for Meta-Agent's response. Returns guidance or still_pending. Worker resumes when guidance arrives.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "user-kg-read-worker",
      "name": "user_kg_read (Worker)",
      "type": "component",
      "layer": "dual-agents",
      "color": "gold",
      "icon": "ðŸ‘¤",
      "description": "Read-only. No writes (injection safety). Worker reads preferences but cannot poison the knowledge graph even if fully compromised.",
      "tags": "[\"worker tool\",\"read-only\",\"new\"]",
      "sort_order": 65,
      "versions": {
        "overview": {
          "content": "Read-only. No writes (injection safety). Worker reads preferences but cannot poison the knowledge graph.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "code-graph-read-worker",
      "name": "code_graph_read (Worker)",
      "type": "component",
      "layer": "dual-agents",
      "color": "emerald",
      "icon": "ðŸ—º",
      "description": "Read-only. Checkpointer writes on Worker's behalf after file edits trigger AST re-parse.",
      "tags": "[\"worker tool\",\"read-only\",\"new\"]",
      "sort_order": 66,
      "versions": {
        "overview": {
          "content": "Read-only. Checkpointer writes on Worker's behalf after file edits trigger AST re-parse.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "shared-state",
      "name": "Shared State Store",
      "type": "layer",
      "layer": null,
      "color": "blue",
      "icon": "ðŸ’¾",
      "description": "The Bridge â€” SQLite WAL / Postgres. Goals, tasks, tool logs, checkpoints, escalations. Both instances communicate by sharing a database, not a connection.",
      "tags": "[\"sqlite wal\",\"postgres\",\"append-only\"]",
      "sort_order": 70,
      "versions": {
        "overview": {
          "content": "SQLite WAL / Postgres. Goals, tasks, tool logs, checkpoints, escalations. The bridge between both instances â€” they share a database, not a connection. Context preservation: What IS saved â€” task ID + current step index, tool call log (name, args, result hash), plan summary (goal queue snapshot), goal queue pointer, timestamps, escalation state. What is NOT saved â€” LLM hidden state (non-serialisable), full conversation history (too large), in-flight reasoning (ephemeral by nature). Tool results are facts; LLM reasoning can be re-derived.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "state-store",
      "name": "State Store",
      "type": "store",
      "layer": "shared-state",
      "color": "blue",
      "icon": "ðŸ’¾",
      "description": "Append-only log that both instances read/write. The Meta-Agent writes goals and reads results. The Worker's Checkpointer writes tool call logs and progress. This is how the two OpenCode instances communicate without direct coupling â€” they share a database, not a connection. Also stores escalation records (question, context, response, status) and fast-path completion records so the Meta-Agent stays aware of tasks it didn't plan. Dashboard reads everything here.",
      "tags": "[\"checkpointer\",\"context rebuilder\",\"crash recovery\"]",
      "sort_order": 71,
      "versions": {
        "mvp": {
          "content": "SQLite WAL database with tables for goals, tasks, and tool_logs. Basic CRUD operations. Both agents read/write via simple SQL. No pruning, no optimization.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "overview": {
          "content": "Append-only log that both instances read/write. The Meta-Agent writes goals and reads results. The Worker's Checkpointer writes tool call logs and progress. This is how the two OpenCode instances communicate without direct coupling â€” they share a database, not a connection. Also stores escalation records (question, context, response, status) and fast-path completion records so the Meta-Agent stays aware of tasks it didn't plan. Dashboard reads everything here.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "v1": {
          "content": "Add checkpoints table, escalation records, fast-path completion records. Context rebuilder queries. Pruning policy (keep last N days). Indexes for common query patterns.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "v2": {
          "content": "SSE/WebSocket push for live dashboard updates. Postgres option for multi-machine deployments. Full audit trail with retention policies. Query optimization for dashboard views.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {
        "mvp": [
          {
            "filename": "mvp-shared-state.feature",
            "title": "Shared State Store (MVP)",
            "content": "Feature: Shared State Store (MVP)\n  The State Store is a SQLite WAL database that both agents\n  read and write. It stores goals, tasks, and tool logs.\n\n  Background:\n    Given the State Store SQLite database exists\n\n  Scenario: Create a goal\n    When a goal \"Build user authentication\" is inserted\n    Then the goal exists with status \"pending\"\n    And the goal has a created_at timestamp\n\n  Scenario: Create tasks for a goal\n    Given a goal exists with id \"goal-1\"\n    When tasks are inserted for goal \"goal-1\"\n    Then each task references the parent goal\n    And each task has status \"pending\" and an ordering index\n\n  Scenario: Log a tool call\n    Given a task exists with id \"task-1\"\n    When a tool call log is inserted with tool \"filesystem\", args hash, and result hash\n    Then the tool log exists with a timestamp\n    And the tool log references \"task-1\"\n\n  Scenario: Both agents can read/write concurrently\n    Given the Meta-Agent is writing a goal\n    And the Worker is writing a tool log\n    Then both writes succeed without conflict\n    And the WAL journal mode handles concurrent access\n\n  Scenario: Query task status by goal\n    Given a goal has 3 tasks with statuses \"complete\", \"in-progress\", \"pending\"\n    When querying tasks for that goal\n    Then all 3 tasks are returned with their statuses\n"
          }
        ]
      }
    },
    {
      "id": "checkpointer",
      "name": "Checkpointer",
      "type": "component",
      "layer": "shared-state",
      "color": "blue",
      "icon": "ðŸ“¸",
      "description": "Taps Worker's Proxy. Writes after every tool response: task ID, tool name, args, result hash, timestamp, plan summary. Also snapshots escalation state so crash recovery can restore a paused-and-waiting Worker correctly. If tool was a file edit, also triggers AST re-parse and Code Graph update. Strategy: tool results are facts; LLM reasoning can be re-derived. So we save the facts (tool call + result) and let the Context Rebuilder regenerate the reasoning frame on recovery. Runs async â€” doesn't block the agent. The proxy fires-and-forgets to the checkpointer; the Worker never waits for a checkpoint write to complete.",
      "tags": "[\"async\",\"fire-and-forget\",\"non-blocking\",\"code graph update\"]",
      "sort_order": 72,
      "versions": {
        "mvp": {
          "content": "Intercept tool responses from Worker proxy. Write task_id, tool_name, args_hash, result_hash, timestamp to State Store. Fire-and-forget (async, non-blocking).",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "overview": {
          "content": "Taps Worker's Proxy. Writes after every tool response: task ID, tool name, args, result hash, timestamp, plan summary. Also snapshots escalation state so crash recovery can restore a paused-and-waiting Worker correctly. If tool was a file edit, triggers AST re-parse and Code Graph update. Strategy: tool results are facts; LLM reasoning can be re-derived. So we save the facts and let the Context Rebuilder regenerate the reasoning frame on recovery. Runs async â€” the proxy fires-and-forgets; the Worker never waits for a checkpoint write to complete.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "v1": {
          "content": "Escalation state snapshots. File-edit detection triggering Code Graph AST re-parse. Plan summary snapshots for context rebuilder. Idempotency markers for crash recovery.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "v2": {
          "content": "Configurable checkpoint granularity. Compressed checkpoint storage. Checkpoint pruning with retention policy. Metrics on checkpoint write latency.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {
        "mvp": [
          {
            "filename": "mvp-checkpointing.feature",
            "title": "Checkpointer (MVP)",
            "content": "Feature: Checkpointer (MVP)\n  The Checkpointer taps the Worker's MCP proxy and records\n  every tool call for crash recovery and progress tracking.\n\n  Background:\n    Given the Checkpointer is attached to the Worker's MCP proxy\n    And the State Store is accessible\n\n  Scenario: Record tool call after response\n    Given the Worker calls the \"filesystem\" tool with args \"read file.ts\"\n    When the tool returns a successful response\n    Then the Checkpointer writes a record to the State Store\n    And the record includes task_id, tool_name, args_hash, result_hash, and timestamp\n\n  Scenario: Non-blocking operation\n    Given the Worker is executing a task\n    When a tool call completes\n    Then the Checkpointer writes asynchronously\n    And the Worker does not wait for the checkpoint write\n\n  Scenario: Maintain ordering of tool calls\n    Given the Worker makes 3 sequential tool calls\n    When all 3 are checkpointed\n    Then the records are ordered by timestamp\n    And each has a sequential index within the task\n\n  Scenario: Handle write failure gracefully\n    Given the State Store is temporarily unavailable\n    When the Checkpointer attempts to write\n    Then it retries with backoff\n    And the Worker execution is not affected\n"
          }
        ]
      }
    },
    {
      "id": "context-rebuilder",
      "name": "Context Rebuilder",
      "type": "component",
      "layer": "shared-state",
      "color": "blue",
      "icon": "ðŸ“",
      "description": "On crash recovery of either instance: generates resume prompt from compressed checkpoint + relevant graph context. For Worker: \"you were doing X, completed Y, next step Z\". For Meta-Agent: \"current goal is X, worker status is Y, pending goals are Z\". If Worker was in paused:awaiting_guidance state, resume prompt includes the escalation question and any response received while it was down. Lossy by design. You can't clone LLM hidden state â€” it's non-serialisable. This is like a save game, not a VM snapshot. The rebuilt context is \"good enough\" â€” the agent continues without knowing it crashed, picking up from the last checkpoint with a compressed summary of what came before.",
      "tags": "[\"lossy by design\",\"save game\",\"resume prompt\"]",
      "sort_order": 73,
      "versions": {
        "mvp": {
          "content": "Read last checkpoint from State Store. Generate basic resume prompt: \"you were doing X, completed Y, next step Z\". Inject as system prompt on respawn.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "overview": {
          "content": "On crash recovery of either instance: generates resume prompt from compressed checkpoint + relevant graph context. For Worker: \"you were doing X, completed Y, next step Z\". For Meta-Agent: \"current goal is X, worker status is Y, pending goals are Z\". If Worker was in paused:awaiting_guidance state, resume prompt includes the escalation question and any response received while it was down. Lossy by design. You can't clone LLM hidden state â€” it's non-serialisable. This is like a save game, not a VM snapshot.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "v1": {
          "content": "Include relevant User KG context in resume prompt. Include Code Graph context for coding tasks. Handle paused:awaiting_guidance state.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "v2": {
          "content": "Compressed multi-checkpoint summaries. Relevance-ranked context selection. Token budget management for resume prompts.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {
        "mvp": [
          {
            "filename": "mvp-context-rebuild.feature",
            "title": "Context Rebuilder (MVP)",
            "content": "Feature: Context Rebuilder (MVP)\n  On crash recovery, the Context Rebuilder generates a resume\n  prompt from the last checkpoint so the agent can continue.\n\n  Background:\n    Given the State Store contains checkpoints for a crashed agent\n\n  Scenario: Generate resume prompt for Worker\n    Given the Worker crashed mid-task on task \"Create login endpoint\"\n    And the last checkpoint shows 3 completed tool calls\n    When the Context Rebuilder generates a resume prompt\n    Then the prompt includes \"you were doing: Create login endpoint\"\n    And it lists the 3 completed tool calls with their results\n    And it states the next expected action\n\n  Scenario: Generate resume prompt for Meta-Agent\n    Given the Meta-Agent crashed while processing goal \"Build auth\"\n    And the goal has 5 tasks, 2 completed and 1 in-progress\n    When the Context Rebuilder generates a resume prompt\n    Then the prompt includes the current goal state\n    And it lists completed and pending tasks\n    And it states the current Worker status\n\n  Scenario: Handle empty checkpoint\n    Given no checkpoints exist for the crashed agent\n    When the Context Rebuilder generates a resume prompt\n    Then it produces a minimal prompt with no prior context\n    And the agent starts fresh\n"
          }
        ]
      }
    },
    {
      "id": "mcp-proxies",
      "name": "MCP Proxies",
      "type": "layer",
      "layer": null,
      "color": "orange",
      "icon": "â‡„",
      "description": "Tool proxy layer for both agent instances. Meta-Agent gets static manifest (10 internal tools, no sanitiser). Worker gets dynamic manifest (hot-swappable, sanitiser required, circuit breaker).",
      "tags": "[\"static manifest\",\"dynamic manifest\",\"hot-swappable\"]",
      "sort_order": 80,
      "versions": {
        "overview": {
          "content": "Tool proxy layer. Meta-Agent gets static manifest (10 internal tools, no sanitiser, low risk). Worker gets dynamic manifest (hot-swappable, sanitiser required, circuit breaker, checkpoint tap).",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "mcp-proxy-meta",
      "name": "MCP Proxy â€” Meta-Agent",
      "type": "component",
      "layer": "mcp-proxies",
      "color": "orange",
      "icon": "â‡„",
      "description": "Hosts 10 planning tools (6 planning + 4 graph). These are your custom MCP servers â€” small, stable, purpose-built. No external API calls, no injection risk.",
      "tags": "[\"static\",\"no sanitiser\",\"low risk\"]",
      "sort_order": 81,
      "versions": {
        "mvp": {
          "content": "Static MCP server hosting goal_queue, state_reader, worker_control tools. Simple stdio transport. No hot-swap needed.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "overview": {
          "content": "Hosts 10 planning tools (6 planning + 4 graph). These are your custom MCP servers â€” small, stable, purpose-built. No external API calls, no injection risk.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "mcp-proxy-worker",
      "name": "MCP Proxy â€” Worker",
      "type": "component",
      "layer": "mcp-proxies",
      "color": "cyan",
      "icon": "â‡„",
      "description": "Hosts all external-facing tools + escalation + graph reads. Dynamic manifest â€” the Meta-Agent's proxy_admin tool adds/removes servers here at runtime. All responses pass through the Sanitiser. Health & circuit breaker: heartbeats downstream servers; dead endpoints auto-removed from manifest, Meta-Agent notified via State Store so it can find replacements.",
      "tags": "[\"sanitiser required\",\"hot-swappable\",\"checkpoint tap\",\"circuit breaker\"]",
      "sort_order": 82,
      "versions": {
        "mvp": {
          "content": "MCP proxy with configurable tool list. Route tool calls to downstream servers. Pass responses through sanitiser. Basic health check on downstream servers.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "overview": {
          "content": "Hosts all external-facing tools + escalation + graph reads. Dynamic manifest â€” Meta-Agent's proxy_admin adds/removes servers at runtime. All responses pass through Sanitiser. Health & circuit breaker: heartbeats downstream servers; dead endpoints auto-removed from manifest, Meta-Agent notified via State Store so it can find replacements.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "security-sandbox",
      "name": "Security Sandbox",
      "type": "layer",
      "layer": null,
      "color": "red",
      "icon": "ðŸ›¡",
      "description": "3-stage sanitiser pipeline (Worker proxy only). Regex heuristics â†’ structural strip (role tags, cap length) â†’ optional LLM classifier. Fail-closed. Isolated subprocess. Scans inbound responses (injection defence) AND outbound tool args (prevents data exfiltration via tricked agent).",
      "tags": "[\"fail-closed\",\"isolated subprocess\",\"bidirectional\"]",
      "sort_order": 90,
      "versions": {
        "overview": {
          "content": "3-stage sanitiser: regex heuristics â†’ structural strip â†’ optional LLM classifier. Fail-closed. Isolated subprocess. Scans inbound + outbound. Worker proxy only. Security model: Meta-Agent has no sanitiser (internal tools only). Worker has full 3-stage sanitiser. Cross-instance isolation: Worker cannot reach Meta-Agent's tools even if fully compromised. Escalation tools are safe: they write structured data to State Store, not free-text to Meta-Agent's prompt. Dashboard is read-only â€” cannot be used as attack vector. Graph writes: Worker cannot write to either graph â€” cannot poison knowledge even if fully compromised. In full-auto mode: sanitiser is the only defence against prompt injection. Write fence still applies for destructive ops. Injection feedback loop lets Meta-Agent auto-disable compromised tools.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "sanitiser",
      "name": "3-Stage Sanitiser",
      "type": "component",
      "layer": "security-sandbox",
      "color": "red",
      "icon": "ðŸ›¡",
      "description": "Sits between Worker's Proxy and downstream servers. Stage 1: Heuristic regex for common injection patterns. Stage 2: Structural strip (remove role tags, cap response length). Stage 3: Optional LLM classifier for sophisticated detection. The Meta-Agent's proxy does NOT need a sanitiser â€” its tools are all internal, no external input. Isolated subprocess. Fail-closed. Scans inbound responses (injection defence) and outbound tool args (prevents data exfiltration via a tricked agent â€” e.g. an injected prompt that encodes secrets into a search query). Injection events visible in dashboard Security Events panel.",
      "tags": "[\"3-stage\",\"fail-closed\",\"isolated subprocess\",\"bidirectional\"]",
      "sort_order": 91,
      "versions": {
        "mvp": {
          "content": "Regex-based heuristic scanner for common injection patterns. Structural strip (remove role tags, cap response length). Pass/block verdict on each tool response. Logging to State Store.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "overview": {
          "content": "Sits between Worker's Proxy and downstream servers. Stage 1: Heuristic regex for common injection patterns. Stage 2: Structural strip (remove role tags, cap response length). Stage 3: Optional LLM classifier for sophisticated detection. The Meta-Agent's proxy does NOT need a sanitiser â€” its tools are all internal, no external input. Isolated subprocess. Fail-closed. Scans inbound responses (injection defence) and outbound tool args (prevents data exfiltration â€” e.g. an injected prompt encoding secrets into a search query). Injection events visible in dashboard Security Events panel.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "v1": {
          "content": "Outbound scanning (prevent data exfiltration via tool args). Configurable rule sets per tool. Injection frequency tracking. Auto-disable tools exceeding threshold. Dashboard integration.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        },
        "v2": {
          "content": "Optional LLM classifier stage. Adaptive rules based on observed attack patterns. Per-tool confidence scoring. Full audit trail with payload samples.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {
        "mvp": [
          {
            "filename": "mvp-sanitiser.feature",
            "title": "3-Stage Sanitiser (MVP)",
            "content": "Feature: 3-Stage Sanitiser (MVP)\n  The Sanitiser sits between the Worker's MCP proxy and downstream\n  tool servers. It scans tool responses for injection attempts.\n\n  Background:\n    Given the Sanitiser is running as an isolated subprocess\n\n  Scenario: Pass clean tool response\n    Given a tool response contains normal text content\n    When the Sanitiser processes the response\n    Then the verdict is \"pass\"\n    And the response is forwarded to the Worker unchanged\n\n  Scenario: Block response with injection pattern\n    Given a tool response contains \"ignore previous instructions\"\n    When the Sanitiser processes the response\n    Then the verdict is \"block\"\n    And the response is not forwarded to the Worker\n    And the injection event is logged to the State Store\n\n  Scenario: Strip role tags from response\n    Given a tool response contains \"<system>\" tags\n    When the Sanitiser applies structural stripping\n    Then the role tags are removed from the response\n    And the cleaned response is forwarded\n\n  Scenario: Cap response length\n    Given a tool response exceeds the maximum allowed length\n    When the Sanitiser processes the response\n    Then the response is truncated to the maximum length\n    And the truncation is noted in the log\n\n  Scenario: Fail closed on processing error\n    Given the Sanitiser encounters an internal error during processing\n    When processing a tool response\n    Then the response is blocked (not forwarded)\n    And the error is logged\n"
          }
        ]
      }
    },
    {
      "id": "alert-pipeline",
      "name": "Alert Pipeline",
      "type": "component",
      "layer": "security-sandbox",
      "color": "red",
      "icon": "ðŸ“‹",
      "description": "Blocked injections logged to State Store. Meta-Agent can auto-disable compromised tools via injection feedback loop â€” reads sanitiser alerts and learns to avoid them. Dashboard shows real-time security events feed.",
      "tags": "[\"auto-disable\",\"injection feedback loop\",\"real-time\"]",
      "sort_order": 92,
      "versions": {
        "overview": {
          "content": "Blocked injections logged to State Store. Meta-Agent can auto-disable compromised tools via injection feedback loop â€” reads sanitiser alerts and learns to avoid them. Dashboard shows real-time security events.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "downstream-tools",
      "name": "Downstream MCP Tool Servers",
      "type": "layer",
      "layer": null,
      "color": "amber",
      "icon": "ðŸ”§",
      "description": "External tool servers â€” search, email, database, filesystem, code execution, custom. Hot-swappable â€” Meta-Agent adds/removes at runtime via proxy_admin.",
      "tags": "[\"external\",\"hot-swappable\",\"runtime managed\"]",
      "sort_order": 100,
      "versions": {
        "overview": {
          "content": "External MCP tool servers. Search, email, database, filesystem, code execution, custom. Hot-swappable â€” Meta-Agent adds/removes at runtime.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "tool-search",
      "name": "Search",
      "type": "external",
      "layer": "downstream-tools",
      "color": "amber",
      "icon": "ðŸ”",
      "description": "External search MCP server.",
      "tags": "[\"ext\"]",
      "sort_order": 101,
      "versions": {
        "overview": {
          "content": "External search MCP server.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "tool-email",
      "name": "Email",
      "type": "external",
      "layer": "downstream-tools",
      "color": "amber",
      "icon": "âœ‰",
      "description": "External email MCP server.",
      "tags": "[\"ext\"]",
      "sort_order": 102,
      "versions": {
        "overview": {
          "content": "External email MCP server.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "tool-database",
      "name": "Database",
      "type": "external",
      "layer": "downstream-tools",
      "color": "amber",
      "icon": "ðŸ—„",
      "description": "External database MCP server.",
      "tags": "[\"write\"]",
      "sort_order": 103,
      "versions": {
        "overview": {
          "content": "External database MCP server.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "tool-filesystem",
      "name": "Filesystem",
      "type": "external",
      "layer": "downstream-tools",
      "color": "amber",
      "icon": "ðŸ“‚",
      "description": "External filesystem MCP server.",
      "tags": "[\"write\"]",
      "sort_order": 104,
      "versions": {
        "overview": {
          "content": "External filesystem MCP server.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "tool-code-exec",
      "name": "Code Exec",
      "type": "external",
      "layer": "downstream-tools",
      "color": "amber",
      "icon": "ðŸ’»",
      "description": "External code execution MCP server.",
      "tags": "[\"write\"]",
      "sort_order": 105,
      "versions": {
        "overview": {
          "content": "External code execution MCP server.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "tool-custom",
      "name": "Custom",
      "type": "external",
      "layer": "downstream-tools",
      "color": "amber",
      "icon": "ðŸ§©",
      "description": "Custom MCP servers â€” hot-swappable, added/removed by Meta-Agent at runtime.",
      "tags": "[\"dynamic\"]",
      "sort_order": 106,
      "versions": {
        "overview": {
          "content": "Custom MCP servers â€” hot-swappable, added/removed by Meta-Agent at runtime.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "bdd-tdd-pipeline",
      "name": "BDD/TDD Phase Pipeline",
      "type": "layer",
      "layer": null,
      "color": "teal",
      "icon": "ðŸ”„",
      "description": "Strict 8-phase pipeline enforced by Meta-Agent, executed by Worker. Each phase is a separate dispatch. Worker sees only the current phase â€” never what comes next. Every phase ends with a git commit creating a clean rollback point. Meta-Agent verifies phase gate before advancing. If gate fails, re-dispatch same phase. Phases â‘¦ and â‘§ are audit-only â€” violations feed back as targeted fix dispatches, then re-audit.",
      "tags": "[\"phase isolation\",\"git commits\",\"gate verification\"]",
      "sort_order": 110,
      "versions": {
        "overview": {
          "content": "Strict 8-phase pipeline enforced by Meta-Agent: Feature â†’ Steps â†’ Units â†’ Red â†’ Green â†’ Refactor â†’ Arch Review â†’ Sec Review. Every phase ends with a git commit. LLM agents are bad at process discipline. Given \"build a login feature\", they'll jump straight to implementation, skip tests, or refactor before proving anything works. Phase isolation prevents this â€” the Worker can't skip ahead because it doesn't know what \"ahead\" is. The forbidden_actions field explicitly blocks forward-leaking behaviour. This turns the Meta-Agent into a process enforcer, not just a task decomposer. Review phases â‘¦ â‘§ are audit-only â€” dispatched as read-only inspections. Worker reports violations but is forbidden from modifying code. Meta-Agent reads the report, dispatches separate fix phases with specific violations as constraints. Prevents the \"fix one thing, break another\" cascade. Phases are extensible: add performance review, accessibility audit, API design review â€” same pattern.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "phase-feature",
      "name": "â‘  Feature",
      "type": "phase",
      "layer": "bdd-tdd-pipeline",
      "color": "gold",
      "icon": "ðŸ“",
      "description": "Write the .feature file. Describe the behaviour in Gherkin. DO NOT write any tests or code. Gate: .feature file exists. Git commit after phase.",
      "tags": "[\"gherkin\",\"gate: .feature exists\"]",
      "sort_order": 111,
      "versions": {
        "overview": {
          "content": "Write the .feature file. Describe the behaviour in Gherkin. DO NOT write any tests or code. Gate: .feature file exists. Git commit after phase.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "phase-steps",
      "name": "â‘¡ Step Tests",
      "type": "phase",
      "layer": "bdd-tdd-pipeline",
      "color": "cyan",
      "icon": "ðŸ§ª",
      "description": "Write failing step definitions for this feature file. DO NOT implement any production code. Gate: step files exist. Git commit after phase.",
      "tags": "[\"failing tests\",\"gate: step files exist\"]",
      "sort_order": 112,
      "versions": {
        "overview": {
          "content": "Write failing step definitions for this feature file. DO NOT implement any production code. Gate: step files exist. Git commit after phase.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "phase-units",
      "name": "â‘¢ Unit Tests",
      "type": "phase",
      "layer": "bdd-tdd-pipeline",
      "color": "purple",
      "icon": "ðŸ§ª",
      "description": "Write failing unit tests for the components you'll need. DO NOT implement any production code. Gate: test files exist. Git commit after phase.",
      "tags": "[\"failing tests\",\"gate: test files exist\"]",
      "sort_order": 113,
      "versions": {
        "overview": {
          "content": "Write failing unit tests for the components you'll need. DO NOT implement any production code. Gate: test files exist. Git commit after phase.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "phase-red",
      "name": "â‘£ Red",
      "type": "phase",
      "layer": "bdd-tdd-pipeline",
      "color": "red",
      "icon": "ðŸ”´",
      "description": "Run all tests. Confirm they fail. Report which tests fail and why. DO NOT fix anything. Gate: tests fail. Git commit after phase.",
      "tags": "[\"confirm failure\",\"gate: tests fail\"]",
      "sort_order": 114,
      "versions": {
        "overview": {
          "content": "Run all tests. Confirm they fail. Report which tests fail and why. DO NOT fix anything. Gate: tests fail. Git commit after phase.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "phase-green",
      "name": "â‘¤ Green",
      "type": "phase",
      "layer": "bdd-tdd-pipeline",
      "color": "green",
      "icon": "ðŸŸ¢",
      "description": "Write the minimum production code to make all tests pass. DO NOT refactor or optimise. Gate: tests pass. Git commit after phase.",
      "tags": "[\"minimum code\",\"gate: tests pass\"]",
      "sort_order": 115,
      "versions": {
        "overview": {
          "content": "Write the minimum production code to make all tests pass. DO NOT refactor or optimise. Gate: tests pass. Git commit after phase.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "phase-refactor",
      "name": "â‘¥ Refactor",
      "type": "phase",
      "layer": "bdd-tdd-pipeline",
      "color": "sky",
      "icon": "ðŸ”§",
      "description": "Refactor for clarity, DRY, naming. All tests must still pass. DO NOT add new functionality. Gate: tests still pass. Git commit after phase.",
      "tags": "[\"clarity\",\"dry\",\"gate: tests still pass\"]",
      "sort_order": 116,
      "versions": {
        "overview": {
          "content": "Refactor for clarity, DRY, naming. All tests must still pass. DO NOT add new functionality. Gate: tests still pass. Git commit after phase.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "phase-arch-review",
      "name": "â‘¦ Arch Review",
      "type": "phase",
      "layer": "bdd-tdd-pipeline",
      "color": "orange",
      "icon": "ðŸ›",
      "description": "LLM-driven audit agent (not a linter). Audit against Clean Architecture standards. Report violations: dependency direction (inner layers importing outer), layer boundary leaks (business logic in controllers, HTTP in domain), abstraction leaks (SQL in repository interface), use case isolation. Traverses Code Graph DATA_FLOW and IMPORTS edges to verify dependency direction structurally. DO NOT fix â€” only report. Report format: {violations: [{file, line, rule, severity, explanation}], passed: bool}. If violations found, Meta-Agent dispatches targeted fix phases then re-runs this review. Gate: 0 violations. Git commit after phase.",
      "tags": "[\"audit-only\",\"clean architecture\",\"gate: 0 violations\"]",
      "sort_order": 117,
      "versions": {
        "overview": {
          "content": "LLM-driven audit agent. Audit against Clean Architecture: dependency direction (inner layers importing outer = violation), layer boundaries (business logic in controllers), abstraction leaks (SQL in repository interface), use case isolation. Traverses Code Graph DATA_FLOW and IMPORTS edges structurally. DO NOT fix â€” only report. Report: {violations: [{file, line, rule, severity, explanation}], passed: bool}. Gate: 0 violations. Git commit after phase.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    },
    {
      "id": "phase-sec-review",
      "name": "â‘§ Sec Review",
      "type": "phase",
      "layer": "bdd-tdd-pipeline",
      "color": "rose",
      "icon": "ðŸ”’",
      "description": "LLM-driven security audit agent. Check: injection vectors (SQL, XSS, command injection, path traversal), auth/authz gaps (endpoints without auth middleware, missing permission checks, privilege escalation), secrets exposure (hardcoded keys, tokens in logs, secrets in error messages, .env leaks), unsafe dependencies (known CVEs, deprecated crypto, insecure defaults). Checks compliance requirements from User KG (e.g. \"client requires SOC2\" â†’ enforce specific controls). DO NOT fix â€” only report. Same report format as Arch Review. Gate: 0 findings. Git commit after phase.",
      "tags": "[\"audit-only\",\"security\",\"gate: 0 findings\",\"user kg compliance\"]",
      "sort_order": 118,
      "versions": {
        "overview": {
          "content": "LLM-driven security audit. Injection vectors (SQL, XSS, command injection, path traversal), auth/authz gaps (missing middleware, privilege escalation), secrets exposure (hardcoded keys, tokens in logs, .env leaks), unsafe dependencies (CVEs, deprecated crypto). Checks User KG compliance requirements (e.g. SOC2). DO NOT fix â€” only report. Same report format. Gate: 0 findings. Git commit after phase.",
          "progress": 0,
          "status": "planned",
          "updated_at": "2026-02-10 09:56:50"
        }
      },
      "features": {}
    }
  ],
  "edges": [
    {
      "id": 56,
      "source_id": "supervisor",
      "target_id": "meta-agent",
      "type": "CONTROLS",
      "label": "spawns + manages",
      "metadata": null
    },
    {
      "id": 57,
      "source_id": "supervisor",
      "target_id": "worker",
      "type": "CONTROLS",
      "label": "spawns + manages",
      "metadata": null
    },
    {
      "id": 58,
      "source_id": "supervisor",
      "target_id": "live-dashboard",
      "type": "CONTROLS",
      "label": "spawns",
      "metadata": null
    },
    {
      "id": 59,
      "source_id": "meta-agent",
      "target_id": "worker",
      "type": "DISPATCHES_TO",
      "label": "phase-locked tasks",
      "metadata": null
    },
    {
      "id": 60,
      "source_id": "worker",
      "target_id": "meta-agent",
      "type": "ESCALATES_TO",
      "label": "via state store",
      "metadata": null
    },
    {
      "id": 61,
      "source_id": "live-dashboard",
      "target_id": "state-store",
      "type": "READS_FROM",
      "label": "goals, tasks, logs",
      "metadata": null
    },
    {
      "id": 62,
      "source_id": "live-dashboard",
      "target_id": "supervisor",
      "type": "READS_FROM",
      "label": "health API",
      "metadata": null
    },
    {
      "id": 63,
      "source_id": "live-process-view",
      "target_id": "supervisor",
      "type": "READS_FROM",
      "label": "process status",
      "metadata": null
    },
    {
      "id": 64,
      "source_id": "goal-task-feed",
      "target_id": "state-store",
      "type": "READS_FROM",
      "label": "goal queue",
      "metadata": null
    },
    {
      "id": 65,
      "source_id": "tool-call-timeline",
      "target_id": "state-store",
      "type": "READS_FROM",
      "label": "tool logs",
      "metadata": null
    },
    {
      "id": 66,
      "source_id": "security-events",
      "target_id": "state-store",
      "type": "READS_FROM",
      "label": "injection events",
      "metadata": null
    },
    {
      "id": 67,
      "source_id": "escalation-queue",
      "target_id": "state-store",
      "type": "READS_FROM",
      "label": "escalations",
      "metadata": null
    },
    {
      "id": 68,
      "source_id": "entity-explorer",
      "target_id": "user-knowledge-graph",
      "type": "READS_FROM",
      "label": "entities",
      "metadata": null
    },
    {
      "id": 69,
      "source_id": "repo-map",
      "target_id": "rpg-code-graph",
      "type": "READS_FROM",
      "label": "code structure",
      "metadata": null
    },
    {
      "id": 70,
      "source_id": "meta-agent",
      "target_id": "state-store",
      "type": "READS_FROM",
      "label": "worker progress",
      "metadata": null
    },
    {
      "id": 71,
      "source_id": "meta-agent",
      "target_id": "state-store",
      "type": "WRITES_TO",
      "label": "goals, tasks",
      "metadata": null
    },
    {
      "id": 72,
      "source_id": "meta-agent",
      "target_id": "user-knowledge-graph",
      "type": "READS_FROM",
      "label": "preferences",
      "metadata": null
    },
    {
      "id": 73,
      "source_id": "meta-agent",
      "target_id": "user-knowledge-graph",
      "type": "WRITES_TO",
      "label": "inferred entities",
      "metadata": null
    },
    {
      "id": 74,
      "source_id": "meta-agent",
      "target_id": "rpg-code-graph",
      "type": "READS_FROM",
      "label": "repo structure",
      "metadata": null
    },
    {
      "id": 75,
      "source_id": "meta-agent",
      "target_id": "rpg-code-graph",
      "type": "WRITES_TO",
      "label": "annotations",
      "metadata": null
    },
    {
      "id": 76,
      "source_id": "worker",
      "target_id": "state-store",
      "type": "READS_FROM",
      "label": "task dispatch",
      "metadata": null
    },
    {
      "id": 77,
      "source_id": "worker",
      "target_id": "user-knowledge-graph",
      "type": "READS_FROM",
      "label": "preferences (read-only)",
      "metadata": null
    },
    {
      "id": 78,
      "source_id": "worker",
      "target_id": "rpg-code-graph",
      "type": "READS_FROM",
      "label": "code structure (read-only)",
      "metadata": null
    },
    {
      "id": 79,
      "source_id": "checkpointer",
      "target_id": "state-store",
      "type": "WRITES_TO",
      "label": "tool logs, checkpoints",
      "metadata": null
    },
    {
      "id": 80,
      "source_id": "checkpointer",
      "target_id": "rpg-code-graph",
      "type": "WRITES_TO",
      "label": "incremental AST updates",
      "metadata": null
    },
    {
      "id": 81,
      "source_id": "context-rebuilder",
      "target_id": "state-store",
      "type": "READS_FROM",
      "label": "checkpoints",
      "metadata": null
    },
    {
      "id": 82,
      "source_id": "context-rebuilder",
      "target_id": "user-knowledge-graph",
      "type": "READS_FROM",
      "label": "relevant context",
      "metadata": null
    },
    {
      "id": 83,
      "source_id": "context-rebuilder",
      "target_id": "rpg-code-graph",
      "type": "READS_FROM",
      "label": "relevant context",
      "metadata": null
    },
    {
      "id": 84,
      "source_id": "meta-agent",
      "target_id": "mcp-proxy-meta",
      "type": "DEPENDS_ON",
      "label": "tool access",
      "metadata": null
    },
    {
      "id": 85,
      "source_id": "worker",
      "target_id": "mcp-proxy-worker",
      "type": "DEPENDS_ON",
      "label": "tool access",
      "metadata": null
    },
    {
      "id": 86,
      "source_id": "sanitiser",
      "target_id": "mcp-proxy-worker",
      "type": "SANITISES",
      "label": "all external I/O",
      "metadata": null
    },
    {
      "id": 87,
      "source_id": "mcp-proxy-worker",
      "target_id": "tool-search",
      "type": "PROXIES",
      "label": null,
      "metadata": null
    },
    {
      "id": 88,
      "source_id": "mcp-proxy-worker",
      "target_id": "tool-email",
      "type": "PROXIES",
      "label": null,
      "metadata": null
    },
    {
      "id": 89,
      "source_id": "mcp-proxy-worker",
      "target_id": "tool-database",
      "type": "PROXIES",
      "label": null,
      "metadata": null
    },
    {
      "id": 90,
      "source_id": "mcp-proxy-worker",
      "target_id": "tool-filesystem",
      "type": "PROXIES",
      "label": null,
      "metadata": null
    },
    {
      "id": 91,
      "source_id": "mcp-proxy-worker",
      "target_id": "tool-code-exec",
      "type": "PROXIES",
      "label": null,
      "metadata": null
    },
    {
      "id": 92,
      "source_id": "mcp-proxy-worker",
      "target_id": "tool-custom",
      "type": "PROXIES",
      "label": null,
      "metadata": null
    },
    {
      "id": 93,
      "source_id": "alert-pipeline",
      "target_id": "state-store",
      "type": "WRITES_TO",
      "label": "security events",
      "metadata": null
    },
    {
      "id": 94,
      "source_id": "alert-pipeline",
      "target_id": "meta-agent",
      "type": "DISPATCHES_TO",
      "label": "auto-disable alerts",
      "metadata": null
    },
    {
      "id": 95,
      "source_id": "human-gate",
      "target_id": "fast-path",
      "type": "GATES",
      "label": "approve/reject",
      "metadata": null
    },
    {
      "id": 96,
      "source_id": "human-gate",
      "target_id": "full-path",
      "type": "GATES",
      "label": "approve/reject",
      "metadata": null
    },
    {
      "id": 97,
      "source_id": "human-gate",
      "target_id": "gated-path",
      "type": "GATES",
      "label": "blocks until approved",
      "metadata": null
    },
    {
      "id": 98,
      "source_id": "fast-path",
      "target_id": "worker",
      "type": "DISPATCHES_TO",
      "label": "direct",
      "metadata": null
    },
    {
      "id": 99,
      "source_id": "full-path",
      "target_id": "meta-agent",
      "type": "DISPATCHES_TO",
      "label": "for decomposition",
      "metadata": null
    },
    {
      "id": 100,
      "source_id": "phase-feature",
      "target_id": "phase-steps",
      "type": "SEQUENCE",
      "label": "commit â†’ gate",
      "metadata": null
    },
    {
      "id": 101,
      "source_id": "phase-steps",
      "target_id": "phase-units",
      "type": "SEQUENCE",
      "label": "commit â†’ gate",
      "metadata": null
    },
    {
      "id": 102,
      "source_id": "phase-units",
      "target_id": "phase-red",
      "type": "SEQUENCE",
      "label": "commit â†’ gate",
      "metadata": null
    },
    {
      "id": 103,
      "source_id": "phase-red",
      "target_id": "phase-green",
      "type": "SEQUENCE",
      "label": "commit â†’ gate",
      "metadata": null
    },
    {
      "id": 104,
      "source_id": "phase-green",
      "target_id": "phase-refactor",
      "type": "SEQUENCE",
      "label": "commit â†’ gate",
      "metadata": null
    },
    {
      "id": 105,
      "source_id": "phase-refactor",
      "target_id": "phase-arch-review",
      "type": "SEQUENCE",
      "label": "commit â†’ gate",
      "metadata": null
    },
    {
      "id": 106,
      "source_id": "phase-arch-review",
      "target_id": "phase-sec-review",
      "type": "SEQUENCE",
      "label": "commit â†’ gate",
      "metadata": null
    }
  ],
  "stats": {
    "total_nodes": 66,
    "total_edges": 106,
    "total_versions": 103,
    "total_features": 11
  }
}